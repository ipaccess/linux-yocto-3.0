From 4dc0c66922604bcb0b611ec8892f98b3bf37e605 Mon Sep 17 00:00:00 2001
From: Jamie Iles <jamie@jamieiles.com>
Date: Thu, 12 May 2011 16:54:34 +0100
Subject: [PATCH 124/228] picoif: add picoif

picoif is a device driver for picoChip PC3XX devices. The driver
allows configuration of the picoArray peripheral and data transport
to and from the picoArray.
---
 drivers/Kconfig                                   |    2 +
 drivers/Makefile                                  |    1 +
 drivers/picochip/Doxyfile                         | 1511 +++++++++++++++++++++
 drivers/picochip/Kconfig                          |   39 +
 drivers/picochip/Makefile                         |   13 +
 drivers/picochip/debug.c                          |  316 +++++
 drivers/picochip/debug.h                          |  194 +++
 drivers/picochip/directdma.c                      |  461 +++++++
 drivers/picochip/directdma_internal.h             |   34 +
 drivers/picochip/dma.c                            |  793 +++++++++++
 drivers/picochip/dma_fifo.c                       |  211 +++
 drivers/picochip/dma_fifo_internal.h              |   80 ++
 drivers/picochip/dma_internal.h                   |   34 +
 drivers/picochip/gpr_interrupt.c                  |  536 ++++++++
 drivers/picochip/gpr_interrupt_internal.h         |   34 +
 drivers/picochip/hwif2.c                          |  732 ++++++++++
 drivers/picochip/hwif2_internal.h                 |   33 +
 drivers/picochip/pc3xx.c                          | 1446 ++++++++++++++++++++
 drivers/picochip/picoarray.h                      |  470 +++++++
 drivers/picochip/picoif_internal.h                |  184 +++
 drivers/picochip/picoif_main.c                    | 1509 ++++++++++++++++++++
 drivers/picochip/picoif_module.h                  |  349 +++++
 drivers/picochip/resource.c                       |  103 ++
 drivers/picochip/resource.h                       |   37 +
 drivers/picochip/utilities_internal.c             |   55 +
 drivers/picochip/utilities_internal.h             |   51 +
 include/linux/picochip/devices/pc302.h            |  151 ++
 include/linux/picochip/devices/pc3xx.h            |  150 ++
 include/linux/picochip/picoif.h                   |  257 ++++
 include/linux/picochip/picoif_ioctl.h             |  200 +++
 include/linux/picochip/transports/directdma.h     |   82 ++
 include/linux/picochip/transports/dma.h           |  116 ++
 include/linux/picochip/transports/gpr_interrupt.h |   99 ++
 include/linux/picochip/transports/hwif2.h         |  131 ++
 34 files changed, 10414 insertions(+), 0 deletions(-)
 create mode 100644 drivers/picochip/Doxyfile
 create mode 100644 drivers/picochip/Kconfig
 create mode 100644 drivers/picochip/Makefile
 create mode 100644 drivers/picochip/debug.c
 create mode 100644 drivers/picochip/debug.h
 create mode 100644 drivers/picochip/directdma.c
 create mode 100644 drivers/picochip/directdma_internal.h
 create mode 100644 drivers/picochip/dma.c
 create mode 100644 drivers/picochip/dma_fifo.c
 create mode 100644 drivers/picochip/dma_fifo_internal.h
 create mode 100644 drivers/picochip/dma_internal.h
 create mode 100644 drivers/picochip/gpr_interrupt.c
 create mode 100644 drivers/picochip/gpr_interrupt_internal.h
 create mode 100644 drivers/picochip/hwif2.c
 create mode 100644 drivers/picochip/hwif2_internal.h
 create mode 100644 drivers/picochip/pc3xx.c
 create mode 100644 drivers/picochip/picoarray.h
 create mode 100644 drivers/picochip/picoif_internal.h
 create mode 100644 drivers/picochip/picoif_main.c
 create mode 100644 drivers/picochip/picoif_module.h
 create mode 100644 drivers/picochip/resource.c
 create mode 100644 drivers/picochip/resource.h
 create mode 100644 drivers/picochip/utilities_internal.c
 create mode 100644 drivers/picochip/utilities_internal.h
 create mode 100644 include/linux/picochip/devices/pc302.h
 create mode 100644 include/linux/picochip/devices/pc3xx.h
 create mode 100644 include/linux/picochip/picoif.h
 create mode 100644 include/linux/picochip/picoif_ioctl.h
 create mode 100644 include/linux/picochip/transports/directdma.h
 create mode 100644 include/linux/picochip/transports/dma.h
 create mode 100644 include/linux/picochip/transports/gpr_interrupt.h
 create mode 100644 include/linux/picochip/transports/hwif2.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index b2d6791..d426fd1 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -108,6 +108,8 @@ source "drivers/dma/Kconfig"
 
 source "drivers/dca/Kconfig"
 
+source "drivers/picochip/Kconfig"
+
 source "drivers/auxdisplay/Kconfig"
 
 source "drivers/uio/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 3344cea..1187b8d 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -43,6 +43,7 @@ obj-$(CONFIG_FB_INTEL)          += video/intelfb/
 
 obj-$(CONFIG_PARPORT)		+= parport/
 obj-y				+= base/ block/ misc/ mfd/ nfc/
+obj-y				+= picochip/
 obj-$(CONFIG_NUBUS)		+= nubus/
 obj-y				+= macintosh/
 obj-$(CONFIG_IDE)		+= ide/
diff --git a/drivers/picochip/Doxyfile b/drivers/picochip/Doxyfile
new file mode 100644
index 0000000..365e1e5
--- /dev/null
+++ b/drivers/picochip/Doxyfile
@@ -0,0 +1,1511 @@
+# Doxyfile 1.5.8
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the
+# iconv built into libc) for the transcoding. See
+# http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = picoif
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number.
+# This could be handy for archiving the generated documentation or
+# if some version control system is used.
+
+PROJECT_NUMBER         =
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
+# base path where the generated documentation will be put.
+# If a relative path is entered, it will be relative to the location
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = docs
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
+# 4096 sub-directories (in 2 levels) under the output directory of each output
+# format and will distribute the generated files over these directories.
+# Enabling this option can be useful when feeding doxygen a huge amount of
+# source files, where putting all generated files in the same directory would
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# The default language is English, other supported languages are:
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
+# Croatian, Czech, Danish, Dutch, Farsi, Finnish, French, German, Greek,
+# Hungarian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian, Polish,
+# Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak, Slovene,
+# Spanish, Swedish, and Ukrainian.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
+# include brief member descriptions after the members that are listed in
+# the file and class documentation (similar to JavaDoc).
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
+# the brief description of a member or function before the detailed description.
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator
+# that is used to form the text in various listings. Each string
+# in this list, if found as the leading text of the brief description, will be
+# stripped from the text and the result after processing the whole list, is
+# used as the annotated text. Otherwise, the brief description is used as-is.
+# If left blank, the following values are used ("$name" is automatically
+# replaced with the name of the entity): "The $name class" "The $name widget"
+# "The $name file" "is" "provides" "specifies" "contains"
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       =
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# Doxygen will generate a detailed section even if there is only a brief
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
+# path before files name in the file list and in the header files. If set
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
+# can be used to strip a user-defined part of the path. Stripping is
+# only done if one of the specified strings matches the left-hand part of
+# the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the
+# path to strip.
+
+STRIP_FROM_PATH        =
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
+# the path mentioned in the documentation of a class, which tells
+# the reader which header file to include in order to use a class.
+# If left blank only the name of the header file containing the class
+# definition is used. Otherwise one should specify the include paths that
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
+# (but less readable) file names. This can be useful is your file systems
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
+# will interpret the first line (until the first dot) of a JavaDoc-style
+# comment as the brief description. If set to NO, the JavaDoc
+# comments will behave just like regular Qt-style comments
+# (thus requiring an explicit @brief command for a brief description.)
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will
+# interpret the first line (until the first dot) of a Qt-style
+# comment as the brief description. If set to NO, the comments
+# will behave just like regular Qt-style comments (thus requiring
+# an explicit \brief command for a brief description.)
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
+# treat a multi-line C++ special comment block (i.e. a block of //! or ///
+# comments) as a brief description. This used to be the default behaviour.
+# The new default is to treat a multi-line C++ comment block as a detailed
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
+# member inherits the documentation from any documented member that it
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
+# a new page for each member. If set to NO, the documentation of a member will
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab.
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts
+# as commands in the documentation. An alias has the form "name=value".
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to
+# put the command \sideeffect (or @sideeffect) in the documentation, which
+# will result in a user-defined paragraph with heading "Side Effects:".
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
+# sources only. Doxygen will then generate output that is more tailored for C.
+# For instance, some of the names that are used will be different. The list
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
+# sources only. Doxygen will then generate output that is more tailored for
+# Java. For instance, namespaces will be presented as packages, qualified
+# scopes will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources only. Doxygen will then generate output that is more tailored for
+# Fortran.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for
+# VHDL.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it parses.
+# With this tag you can assign which parser to use for a given extension.
+# Doxygen has a built-in mapping, but you can override or extend it using this tag.
+# The format is ext=language, where ext is a file extension, and language is one of
+# the parsers supported by doxygen: IDL, Java, Javascript, C#, C, C++, D, PHP,
+# Objective-C, Python, Fortran, VHDL, C, C++. For instance to make doxygen treat
+# .inc files as Fortran files (default is PHP), and .f files as C (default is Fortran),
+# use: inc=Fortran f=C
+
+EXTENSION_MAPPING      =
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should
+# set this tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
+# func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
+# Doxygen will parse them like normal C++ but will assume all classes use public
+# instead of private inheritance when no explicit protection keyword is present.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate getter
+# and setter methods for a property. Setting this option to YES (the default)
+# will make doxygen to replace the get and set methods by a property in the
+# documentation. This will only work if the methods are indeed getting or
+# setting a simple type. If this is not the case, or you want to show the
+# methods anyway, you should set this option to NO.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES, then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of
+# the same type (for instance a group of public functions) to be put as a
+# subgroup of that type (e.g. under the Public Functions section). Set it to
+# NO to prevent subgrouping. Alternatively, this can be done per class using
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
+# is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically
+# be useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to
+# determine which symbols to keep in memory and which to flush to disk.
+# When the cache is full, less often used symbols will be written to disk.
+# For small to medium size projects (<1000 input files) the default value is
+# probably good enough. For larger projects a too small cache size can cause
+# doxygen to be busy swapping symbols to and from disk most of the time
+# causing a significant performance penality.
+# If the system has enough physical memory increasing the cache will improve the
+# performance by keeping more symbols in memory. Note that the value works on
+# a logarithmic scale so increasing the size by one will rougly double the
+# memory usage. The cache size is given by this formula:
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,
+# corresponding to a cache size of 2^16 = 65536 symbols
+
+SYMBOL_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
+# documentation are documented, even if no documentation was available.
+# Private class members and static file members will be hidden unless
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = YES
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file
+# will be included in the documentation.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
+# defined locally in source files will be included in the documentation.
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local
+# methods, which are defined in the implementation section but not in
+# the interface are included in the documentation.
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base
+# name of the file that contains the anonymous namespace. By default
+# anonymous namespace are hidden.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
+# undocumented members of documented classes, files or namespaces.
+# If set to NO (the default) these members will be included in the
+# various overviews, but no documentation section is generated.
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy.
+# If set to NO (the default) these classes will be included in the various
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
+# friend (class|struct|union) declarations.
+# If set to NO (the default) these declarations will be included in the
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
+# documentation blocks found inside the body of a function.
+# If set to NO (the default) these blocks will be appended to the
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation
+# that is typed after a \internal command is included. If the tag is set
+# to NO (the default) then the documentation will be excluded.
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
+# file names in lower-case letters. If set to YES upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
+# will show members with their full class and namespace scopes in the
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
+# will put a list of the files that are included by a file in the documentation
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
+# will sort the (detailed) documentation of file and class members
+# alphabetically by member name. If set to NO the members will appear in
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
+# brief documentation of file, namespace and class members alphabetically
+# by member name. If set to NO (the default) the members will appear in
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
+# hierarchy of group names into alphabetical order. If set to NO (the default)
+# the group names will appear in their defined order.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
+# sorted by fully-qualified names, including namespaces. If set to
+# NO (the default), the class list will be sorted only by class name,
+# not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or
+# disable (NO) the todo list. This list is created by putting \todo
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or
+# disable (NO) the test list. This list is created by putting \test
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or
+# disable (NO) the bug list. This list is created by putting \bug
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
+# disable (NO) the deprecated list. This list is created by putting
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines
+# the initial value of a variable or define consists of for it to appear in
+# the documentation. If the initializer consists of more lines than specified
+# here it will be hidden. Use a value of 0 to hide initializers completely.
+# The appearance of the initializer of individual variables and defines in the
+# documentation can be controlled using \showinitializer or \hideinitializer
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated
+# at the bottom of the documentation of classes and structs. If set to YES the
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page.
+# This will remove the Files entry from the Quick Index and from the
+# Folder Tree View (if specified). The default is YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the
+# Namespaces page.
+# This will remove the Namespaces entry from the Quick Index
+# and from the Folder Tree View (if specified). The default is YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command <command> <input-file>, where <command> is the value of
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
+# provided by doxygen. Whatever the program writes to standard output
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed by
+# doxygen. The layout file controls the global structure of the generated output files
+# in an output format independent way. The create the layout file that represents
+# doxygen's defaults, run doxygen with the -l option. You can optionally specify a
+# file name after the option, if omitted DoxygenLayout.xml will be used as the name
+# of the layout file.
+
+LAYOUT_FILE            =
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated by doxygen. Possible values are YES and NO. If left blank
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some
+# parameters in a documented function, or documenting parameters that
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for
+# functions that are documented, but have no documentation for their parameters
+# or return value. If set to NO (the default) doxygen will only warn about
+# wrong or incomplete parameter documentation, but not about the absence of
+# documentation.
+
+WARN_NO_PARAMDOC       = YES
+
+# The WARN_FORMAT tag determines the format of the warning messages that
+# doxygen can produce. The string should contain the $file, $line, and $text
+# tags, which will be replaced by the file and line number from which the
+# warning originated and the warning text. Optionally the format may contain
+# $version, which will be replaced by the version of the file (if it could
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning
+# and error messages should be written. If left blank the output is written
+# to stderr.
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain
+# documented source files. You may enter file names like "myfile.cpp" or
+# directories like "/usr/src/myproject". Separate the files or directories
+# with spaces.
+
+INPUT                  = . ../../include/linux/picochip
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
+# also the default input encoding. Doxygen uses libiconv (or the iconv built
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
+# the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
+# and *.h) to filter out the source-files in the directories. If left
+# blank the following patterns are tested:
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
+
+FILE_PATTERNS          =
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories
+# should be searched for input files as well. Possible values are YES and NO.
+# If left blank NO is used.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = soft_reset.c soft_reset_memif.h ../../include/linux/picochip/fpga_cpe20x.h ../../include/linux/picochip/gpio.h ../../include/linux/picochip/cpld_hdp102.c cpld_cpe20x.h fpga_cpe20x_main.c cpld_hdp102.c
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or
+# directories that are symbolic links (a Unix filesystem feature) are excluded
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories. Note that the wildcards are matched
+# against the file with absolute path, so to exclude all test directories
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or
+# directories that contain example code fragments that are included (see
+# the \include command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
+# and *.h) to filter out the source-files in the directories. If left
+# blank all files are included.
+
+EXAMPLE_PATTERNS       =
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude
+# commands irrespective of the value of the RECURSIVE tag.
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or
+# directories that contain image that are included in the documentation (see
+# the \image command).
+
+IMAGE_PATH             =
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command <filter> <input-file>, where <filter>
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
+# input file. Doxygen will then use the output that the filter program writes
+# to standard output.
+# If FILTER_PATTERNS is specified, this tag will be
+# ignored.
+
+INPUT_FILTER           = "grep -v \"EXPORT_SYMBOL\|module_init\|module_exit\|MODULE_LICENSE\|MODULE_AUTHOR\|MODULE_DESCRIPTION\" "
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis.
+# Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match.
+# The filters are a list of the form:
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER
+# is applied to all files.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will be used to filter the input files when producing source
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will
+# be generated. Documented entities will be cross-referenced with these sources.
+# Note: To get rid of all source code in the generated output, make sure also
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
+# doxygen to hide any special comment blocks from generated source code
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES
+# then for each documented function all documented
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES
+# then for each documented function all documented entities
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
+# link to the source code.
+# Otherwise they will link to the documentation.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code
+# will point to the HTML generated by the htags(1) tool instead of doxygen
+# built-in source browser. The htags tool is part of GNU's global source
+# tagging system (see http://www.gnu.org/software/global/global.html). You
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
+# will generate a verbatim copy of the header file for each class for
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
+# of all compounds will be generated. Enable this if the project
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all
+# classes will be put under the same header in the alphabetical index.
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = .
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for
+# each generated HTML page. If it is left blank doxygen will generate a
+# standard header.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for
+# each generated HTML page. If it is left blank doxygen will generate a
+# standard footer.
+
+HTML_FOOTER            =
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
+# style sheet that is used by each HTML page. It can be used to
+# fine-tune the look of the HTML output. If the tag is left blank doxygen
+# will generate a default style sheet. Note that doxygen will try to copy
+# the style sheet file to the HTML output directory, so don't put your own
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        =
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,
+# files or namespaces will be aligned in HTML using tables. If set to
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded. For this to work a browser that supports
+# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox
+# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files
+# will be generated that can be used as input for Apple's Xcode 3
+# integrated development environment, introduced with OSX 10.5 (Leopard).
+# To create a documentation set, doxygen will generate a Makefile in the
+# HTML output directory. Running make will produce the docset in that
+# directory and running "make install" will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
+# it at startup.
+# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html for more information.
+
+GENERATE_DOCSET        = NO
+
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
+# feed. A documentation feed provides an umbrella under which multiple
+# documentation sets from a single provider (such as a company or product suite)
+# can be grouped.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
+# should uniquely identify the documentation set bundle. This should be a
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
+# will append .docset to the name.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files
+# will be generated that can be used as input for tools like the
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm)
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
+# be used to specify the file name of the resulting .chm file. You
+# can add a path in front of the file if the result should not be
+# written to the html output directory.
+
+CHM_FILE               =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
+# be used to specify the location (absolute path including file name) of
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
+# controls if a separate .chi index file is generated (YES) or that
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file
+# content.
+
+CHM_INDEX_ENCODING     =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
+# controls whether a binary table of contents is generated (YES) or a
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and QHP_VIRTUAL_FOLDER
+# are set, an additional index file will be generated that can be used as input for
+# Qt's qhelpgenerator to generate a Qt Compressed Help (.qch) of the generated
+# HTML documentation.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can
+# be used to specify the file name of the resulting .qch file.
+# The path specified is relative to the HTML output folder.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating
+# Qt Help Project output. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#namespace
+
+QHP_NAMESPACE          =
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating
+# Qt Help Project output. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#virtual-folders
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to add.
+# For more information please see
+# http://doc.trolltech.com/qthelpproject.html#custom-filters
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the custom filter to add.For more information please see
+# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">Qt Help Project / Custom Filters</a>.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this project's
+# filter section matches.
+# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">Qt Help Project / Filter Attributes</a>.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can
+# be used to specify the location of Qt's qhelpgenerator.
+# If non-empty doxygen will try to run qhelpgenerator on the generated
+# .qhp file.
+
+QHG_LOCATION           =
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at
+# top of each HTML page. The value NO (the default) enables the index and
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20])
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information.
+# If the tag value is set to FRAME, a side panel will be generated
+# containing a tree-like index structure (just like the one that
+# is generated for HTML Help). For this to work a browser that supports
+# JavaScript, DHTML, CSS and frames is required (for instance Mozilla 1.0+,
+# Netscape 6.0+, Internet explorer 5.0+, or Konqueror). Windows users are
+# probably better off using the HTML help feature. Other possible values
+# for this tag are: HIERARCHIES, which will generate the Groups, Directories,
+# and Class Hierarchy pages using a tree view instead of an ordered list;
+# ALL, which combines the behavior of FRAME and HIERARCHIES; and NONE, which
+# disables this behavior completely. For backwards compatibility with previous
+# releases of Doxygen, the values YES and NO are equivalent to FRAME and NONE
+# respectively.
+
+GENERATE_TREEVIEW      = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
+# used to set the initial width (in pixels) of the frame in which the tree
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+# Use this tag to change the font size of Latex formulas included
+# as images in the HTML documentation. The default is 10. Note that
+# when you change the font size after a successful doxygen run you need
+# to manually remove any form_*.png images from the HTML output directory
+# to force them to be regenerated.
+
+FORMULA_FONTSIZE       = 10
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
+# generate Latex output.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked. If left blank `latex' will be used as the default command name.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
+# generate index for LaTeX. If left blank `makeindex' will be used as the
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
+# LaTeX documents. This may be useful for small projects and may help to
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used
+# by the printer. Possible values are: a4, a4wide, letter, legal and
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for
+# the generated latex document. The header should contain everything until
+# the first chapter. If it is left blank doxygen will generate a
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will
+# contain links (just like the HTML output) instead of page references
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
+# plain latex in the generated Makefile. Set this option to YES to get a
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
+# command to the generated LaTeX files. This will instruct LaTeX to keep
+# running if errors occur, instead of asking the user for help.
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not
+# include the index chapters (such as File Index, Compound Index, etc.)
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
+# The RTF output is optimized for Word 97 and may not look very pretty with
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact
+# RTF documents. This may be useful for small projects and may help to
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
+# will contain hyperlink fields. The RTF file will
+# contain links (just like the HTML output) instead of page references.
+# This makes the output suitable for online browsing using WORD or other
+# programs which support those fields.
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's
+# config file, i.e. a series of assignments. You only have to provide
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an rtf document.
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    =
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output,
+# then it will generate one additional man file for each entity
+# documented in the real man page(s). These additional files
+# only source the real man page, but without them the man command
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will
+# generate an XML file that captures the structure of
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema,
+# which can be used by a validating XML parser to check the
+# syntax of the XML files.
+
+XML_SCHEMA             =
+
+# The XML_DTD tag can be used to specify an XML DTD,
+# which can be used by a validating XML parser to check the
+# syntax of the XML files.
+
+XML_DTD                =
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will
+# dump the program listings (including syntax highlighting
+# and cross-referencing information) to the XML output. Note that
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
+# generate an AutoGen Definitions (see autogen.sf.net) file
+# that captures the structure of the code including all
+# documentation. Note that this feature is still experimental
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will
+# generate a Perl module file that captures the structure of
+# the code including all documentation. Note that this
+# feature is still experimental and incomplete at the
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
+# nicely formatted so it can be parsed by a human reader.
+# This is useful
+# if you want to understand what is going on.
+# On the other hand, if this
+# tag is set to NO the size of the Perl module output will be much smaller
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
+# This is useful so different doxyrules.make files included by the same
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
+# evaluate all C-preprocessor directives found in the sources and include
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
+# names in the source code. If set to NO (the default) only conditional
+# compilation will be performed. Macro expansion can be done in a controlled
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
+# then the macro expansion is limited to the macros specified with the
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by
+# the preprocessor.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will
+# be used.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that
+# are defined before the preprocessor is started (similar to the -D option of
+# gcc). The argument of the tag is a list of macros of the form: name
+# or name=definition (no spaces). If the definition and the = are
+# omitted =1 is assumed. To prevent a macro definition from being
+# undefined via #undef or recursively expanded use the := operator
+# instead of the = operator.
+
+PREDEFINED             = __KERNEL__ \
+                         CONFIG_DEBUG_FS
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
+# this tag can be used to specify a list of macro names that should be expanded.
+# The macro definition that is found in the sources will be used.
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
+# doxygen's preprocessor will remove all function-like macros that are alone
+# on a line, have an all uppercase name, and do not end with a semicolon. Such
+# function macros are typically used for boiler-plate code, and will confuse
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles.
+# Optionally an initial location of the external documentation
+# can be added for each tagfile. The format of a tag file without
+# this location is as follows:
+#
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+#
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where "loc1" and "loc2" can be relative or absolute paths or
+# URLs. If a location is present for each tag, the installdox tool
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed
+# in the class index. If set to NO only the inherited external classes
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
+# or super classes. Setting the tag to NO turns the diagrams off. Note that
+# this option is superseded by the HAVE_DOT option below. This is only a
+# fallback. It is recommended to install and use dot, since it yields more
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            =
+
+# If set to YES, the inheritance and collaboration graphs will hide
+# inheritance and usage relations if the target is undocumented
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz, a graph visualization
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = YES
+
+# By default doxygen will write a font called FreeSans.ttf to the output
+# directory and reference it in all dot files that doxygen generates. This
+# font does not include all possible unicode characters however, so when you need
+# these (or just want a differently looking font) you can specify the font name
+# using DOT_FONTNAME. You need need to make sure dot is able to find the font,
+# which can be done by putting it in a standard location or by setting the
+# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory
+# containing the font.
+
+DOT_FONTNAME           = FreeSans
+
+# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.
+# The default size is 10pt.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the output directory to look for the
+# FreeSans.ttf font (which doxygen will put there itself). If you specify a
+# different font using DOT_FONTNAME you can set the path where dot
+# can find it using this tag.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for each documented class showing the direct and
+# indirect inheritance relations. Setting this tag to YES will force the
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for each documented class showing the direct and
+# indirect implementation dependencies (inheritance, containment, and
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+
+UML_LOOK               = YES
+
+# If set to YES, the inheritance and collaboration graphs will show the
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
+# tags are set to YES then doxygen will generate a graph for each documented
+# file showing the direct and indirect include dependencies of the file with
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each
+# documented header file showing the documented files that directly or
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then
+# doxygen will generate a call dependency graph for every global function
+# or class method. Note that enabling this option will significantly increase
+# the time of a run. So in most cases it will be better to enable call graphs
+# for selected functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
+# doxygen will generate a caller dependency graph for every global function
+# or class method. Note that enabling this option will significantly increase
+# the time of a run. So in most cases it will be better to enable caller
+# graphs for selected functions only using the \callergraph command.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES
+# then doxygen will show the dependencies a directory has on other directories
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               =
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the
+# \dotfile command).
+
+DOTFILE_DIRS           =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of
+# nodes that will be shown in the graph. If the number of nodes in a graph
+# becomes larger than this value, doxygen will truncate the graph, which is
+# visualized by representing a node as a red box. Note that doxygen if the
+# number of direct children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
+# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
+# graphs generated by dot. A depth value of 3 means that only nodes reachable
+# from the root by following a path via at most 3 edges will be shown. Nodes
+# that lay further from the root node will be omitted. Note that setting this
+# option to 1 or 2 may greatly reduce the computation time needed for large
+# code bases. Also note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not
+# seem to support this out of the box. Warning: Depending on the platform used,
+# enabling this option may lead to badly anti-aliased labels on the edges of
+# a graph (i.e. they become hard to read).
+
+DOT_TRANSPARENT        = YES
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10)
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
+# generate a legend page explaining the meaning of the various boxes and
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
+# remove the intermediate dot files that are used to generate
+# the various graphs.
+
+DOT_CLEANUP            = YES
+
+#---------------------------------------------------------------------------
+# Options related to the search engine
+#---------------------------------------------------------------------------
+
+# The SEARCHENGINE tag specifies whether or not a search engine should be
+# used. If set to NO the values of all tags below this one will be ignored.
+
+SEARCHENGINE           = NO
diff --git a/drivers/picochip/Kconfig b/drivers/picochip/Kconfig
new file mode 100644
index 0000000..a52f5c1
--- /dev/null
+++ b/drivers/picochip/Kconfig
@@ -0,0 +1,39 @@
+# $picoChipHeaderSubst$
+#
+# picoChip device drivers
+#
+
+menu "picoChip Drivers"
+
+config PICOCHIP
+    tristate
+
+config PICOIF
+    tristate "picoIf driver"
+    ---help---
+      This driver provides a kernelspace API for accessing picoArray devices
+      and a userspace interface through /dev/picoif
+
+config PICOIF_PC3XX
+    bool "PC3XX picoIf support"
+    depends on PICOIF && ARCH_PICOXCELL  && DW_DMAC
+    ---help---
+      Selecting yes here enables PC3XX support in picoIf.
+
+config PICOIF_DEFAULT_DEBUG_LEVEL
+    int "Default debugging level for the picoIf driver (0 = quiet, 9 = noisy)"
+    default "1"
+    help
+      This sets the default debug verbosity of the driver at load time. The
+      values for each component may then be ajusted with the *lvl entries in
+      /debug/picoif/.
+
+config PICOIF_DEBUG_TO_CONSOLE
+    bool "Print picoIf debug messages to the console"
+    default false
+    help
+      Enabling this causes picoIf debug messages to be printed to the console
+      in addition to the debug log in /debug/picoconnect/log. This is mainly
+      useful when working on the drivers themselves.
+
+endmenu
diff --git a/drivers/picochip/Makefile b/drivers/picochip/Makefile
new file mode 100644
index 0000000..85c3d05
--- /dev/null
+++ b/drivers/picochip/Makefile
@@ -0,0 +1,13 @@
+# $picoChipHeaderSubst$
+#
+# Makefile for pico driver
+
+obj-$(CONFIG_PICOIF)	      	+= picoif.o
+picoif-y := picoif_main.o resource.o \
+	    debug.o gpr_interrupt.o dma.o \
+	    dma_fifo.o hwif2.o utilities_internal.o \
+	    directdma.o
+
+picoifktest-y := kerneltest.o
+
+picoif-$(CONFIG_PICOIF_PC3XX)	+= pc3xx.o
diff --git a/drivers/picochip/debug.c b/drivers/picochip/debug.c
new file mode 100644
index 0000000..9c77d46
--- /dev/null
+++ b/drivers/picochip/debug.c
@@ -0,0 +1,316 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file debug.c
+ * \brief picoIf debug implementation.
+ *
+ * This file implements functions for reading and writing debug messages
+ * through debugfs.
+ */
+
+#include <linux/module.h>
+#include <stdarg.h>
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/configfs.h>
+#include <linux/kfifo.h>
+#include <asm/uaccess.h>
+#include "debug.h"
+
+#ifdef CONFIG_DEBUG_FS
+
+/*! The maximum number of bytes that may be stored in the ring buffer. If the
+ *  ring fills, the oldest data will be lost first. */
+#define DEBUG_RING_SIZE  32768
+
+/*! The maximum length of a debug message. Messages longer than this will be
+ *  truncated. */
+#define MAX_MSG_LEN     256
+
+/*! The current picoIf debug level. */
+static u8 picoif_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current PC3XX debug level. */
+static u8 pc3xx_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current AXI2Cfg debug level. */
+static u8 axi2cfg_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current GPR interrupt transport module debug level. */
+static u8 gpr_int_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current DMA transport module debug level. */
+static u8 dma_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current HwIf2 transport module debug level. */
+static u8 hwif2_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+/*! The current debug module debug level. */
+static u8 debug_dbg_lvl = CONFIG_PICOIF_DEFAULT_DEBUG_LEVEL;
+
+/*! picoIf debug component. */
+struct dbg_component picoif_dbg_component = {
+    .curr_lvl   = &picoif_dbg_lvl,
+    .name       = "picoif",
+};
+
+/*! PC3XX debug component. */
+struct dbg_component pc3xx_dbg_component = {
+    .curr_lvl   = &pc3xx_dbg_lvl,
+    .name       = "pc3xx",
+};
+
+/*! AXI2Cfg debug component. */
+struct dbg_component axi2cfg_dbg_component = {
+    .curr_lvl   = &axi2cfg_dbg_lvl,
+    .name       = "axi2cfg",
+};
+
+/*! GPR interrupt debug component. */
+struct dbg_component gpr_int_dbg_component = {
+    .curr_lvl   = &gpr_int_dbg_lvl,
+    .name       = "gpr_int",
+};
+
+/*! DMA debug component. */
+struct dbg_component dma_dbg_component = {
+    .curr_lvl   = &dma_dbg_lvl,
+    .name       = "dma",
+};
+
+/*! HwIF2 debug component. */
+struct dbg_component hwif2_dbg_component = {
+    .curr_lvl   = &hwif2_dbg_lvl,
+    .name       = "hwif2",
+};
+
+/*! Debug module debug component. */
+struct dbg_component debug_dbg_component = {
+    .curr_lvl   = &debug_dbg_lvl,
+    .name       = "debug",
+};
+
+/*! The debug ring itself. */
+static struct kfifo debug_ring;
+
+/*! The spinlock protecting the ring. */
+static spinlock_t debug_ring_lock;
+
+/*! Temorary structure for storing messages before writing to the ring buffer.
+ */
+static char msg_buf[ MAX_MSG_LEN ];
+
+/*!
+ * Move the len bytes of msg_buf into the debug ring.
+ *
+ * @param len The number of bytes to move into the debug ring. If there isn't
+ * enough space, then discard some old data to make sure it fits.
+ * @return Returns the number of bytes put into the debug ring.
+ */
+ssize_t
+static __pc_debug_put( size_t len )
+{
+    size_t space;
+    ssize_t ret;
+
+    space = DEBUG_RING_SIZE - kfifo_len( &debug_ring );
+
+    /* If there isn't enough space in the fifo for the message, then discard
+     * the oldest data so that we can fit the latest message in. */
+    if ( len > space )
+        debug_ring.kfifo.out += ( len - space ) + 16;
+
+    ret = kfifo_in( &debug_ring, msg_buf, len );
+
+    return ret;
+}
+
+ssize_t
+pc_debug_print( const char *component,
+                const char *fmt,
+                ... )
+{
+    va_list args;
+    int len;
+    int added;
+
+    len = sprintf( msg_buf, "[%s] ", component );
+    added = __pc_debug_put( len );
+#ifdef CONFIG_PICOIF_DEBUG_TO_CONSOLE
+    printk( msg_buf );
+#endif /* CONFIG_PICOIF_DEBUG_TO_CONSOLE */
+
+    va_start( args, fmt );
+    len = vsnprintf( msg_buf, sizeof( msg_buf ), fmt, args );
+#ifdef CONFIG_PICOIF_DEBUG_TO_CONSOLE
+    printk( msg_buf );
+#endif /* CONFIG_PICOIF_DEBUG_TO_CONSOLE */
+    va_end( args );
+    added += __pc_debug_put( len );
+
+    return added;
+}
+EXPORT_SYMBOL( pc_debug_print );
+
+/*!
+ * Dump the debug ring to the console.
+ */
+void
+debug_dump( void )
+{
+    char tmp;
+
+    while ( kfifo_out_locked( &debug_ring, &tmp, 1, &debug_ring_lock ) )
+        printk( "%c", tmp );
+    printk( "\n" );
+}
+EXPORT_SYMBOL( debug_dump );
+
+/*!
+ * Open method for the debug ring file.
+ *
+ * @param inode The inode of the debugfs log entry.
+ * @param filp File structure for the opened instance.
+ * @return Always returns zero.
+ */
+static int
+debug_log_open( struct inode *inode,
+                struct file *filp )
+{
+    return 0;
+}
+
+/*!
+ * Read from the debug ring.
+ *
+ * @param filp The file structure for the instance.
+ * @param buf The buffer to write the debug messages into.
+ * @param count The maximum number of bytes to read.
+ * @param offp The offset in the file.
+ * @return Returns the number of bytes read from the ring.
+ */
+static ssize_t
+debug_log_read( struct file *filp,
+                char __user *buf,
+                size_t count,
+                loff_t *offp )
+{
+    char *tmp_buf = kmalloc( count, GFP_KERNEL );
+    int ret = -ENOMEM;
+    unsigned nbytes;
+    if ( !tmp_buf )
+        goto out;
+
+    nbytes = kfifo_out_locked( &debug_ring, tmp_buf, count, &debug_ring_lock );
+    ret = copy_to_user( buf, tmp_buf, nbytes );
+    if ( !ret )
+        ret = nbytes;
+out:
+    if ( tmp_buf )
+        kfree( tmp_buf );
+    return ret;
+}
+
+/*!
+ * Seek the debug log. The log isn't seekable as the output is consumed as it
+ * is read.
+ *
+ * @param filp File structure for the open instance.
+ * @param orig The original offset in the file.
+ * @param offset The offset to seek from orig.
+ * @return Always returns zero.
+ */
+static loff_t
+debug_log_lseek( struct file *filp,
+                 loff_t orig,
+                 int offset )
+{
+    return orig;
+}
+
+/*!
+ * Release method for the debug log.
+ *
+ * @param inode The inode of the debugfs log entry.
+ * @param filp The file structure for the open instance.
+ * @return Always returns zero.
+ */
+static int
+debug_log_release( struct inode *inode,
+                   struct file *filp )
+{
+    return 0;
+}
+
+/*! File operations for the debugfs log entry. */
+static struct file_operations debug_log_fops = {
+    .open       = debug_log_open,
+    .read       = debug_log_read,
+    .llseek     = debug_log_lseek,
+    .release    = debug_log_release,
+};
+
+struct dentry *
+pc_debug_create_log_file( struct dentry *parent )
+{
+    if ( kfifo_alloc( &debug_ring, DEBUG_RING_SIZE, GFP_KERNEL ) )
+        goto fail;
+
+    PRINTD( COMPONENT_DEBUG, DBG_TRACE, "debugfs log initialised" );
+
+    debugfs_create_u8( "picoif_dbg_lvl", 0644, parent, &picoif_dbg_lvl );
+#ifdef CONFIG_PICOIF_PC3XX
+    debugfs_create_u8( "pc3xx_dbg_lvl", 0644, parent, &pc3xx_dbg_lvl );
+#endif /* CONFIG_PICOIF_PC3XX */
+#ifdef CONFIG_PICOIF_PC3XX
+    debugfs_create_u8( "axi2cfg_dbg_lvl", 0644, parent, &axi2cfg_dbg_lvl );
+#endif /* CONFIG_PICOIF_PC3XX */
+    debugfs_create_u8( "gpr_int_dbg_lvl", 0644, parent, &gpr_int_dbg_lvl );
+    debugfs_create_u8( "dma_dbg_lvl", 0644, parent, &dma_dbg_lvl );
+    debugfs_create_u8( "hwif2_dbg_lvl", 0644, parent, &hwif2_dbg_lvl );
+    debugfs_create_u8( "debug_dbg_lvl", 0644, parent, &debug_dbg_lvl );
+
+    spin_lock_init( &debug_ring_lock );
+
+    return debugfs_create_file( "log", 0444, parent, NULL, &debug_log_fops );
+fail:
+    return NULL;
+}
+
+void
+pc_debug_close( void )
+{
+    kfifo_free( &debug_ring );
+}
+
+#else  /* CONFIG_DEBUG_FS */
+
+/*!
+ * Create a log file for the driver in debugfs. If debugfs is not enabled,
+ * this will do nothing.
+ *
+ * @param parent Ignored.
+ * @return Always returns NULL.
+ */
+struct dentry *
+debug_create_log_file( struct dentry *parent )
+{
+    return NULL;
+}
+
+ssize_t
+pc_debug_print( const char *fmt,
+                ... )
+{
+    return -ENODEV;
+}
+
+#endif /* CONFIG_DEBUG_FS */
diff --git a/drivers/picochip/debug.h b/drivers/picochip/debug.h
new file mode 100644
index 0000000..3949fae
--- /dev/null
+++ b/drivers/picochip/debug.h
@@ -0,0 +1,194 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/* Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file debug.h
+ * \brief picoIf debug definitions.
+ *
+ * This file defines a set of macros and functions for adding debug into the
+ * picoIf driver. All debug information is exported through debugfs.
+ *
+ * \page debugging Debugging the picoIf driver
+ *
+ * \section introduction Introduction
+ *
+ * The picoIf kernel module provides some debug capability through debugfs. If
+ * the kernel is compiled with debugfs support, then picoIf will create a
+ * hierarchy in /debug/picoif. A typical hierarchy (depending on what
+ * transports and devices are enabled) may look like:
+ *
+ * \code
+ * root@picocpe:~# ls /debug/picoif/
+ * debug_dbg_lvl    gpr_int_dbg_lvl  pc3xx_dbg_lvl    dma_dbg_lvl
+ * log              picoif_dbg_lvl
+ * \endcode
+ *
+ * Each of these *lvl files contain the current logging level of that
+ * component where higher numbers are decreasing priority. These levels can be
+ * queried and set by accessing the file. For example, to set the PC3xx debug
+ * level to 5:
+ *
+ * \code
+ * root@picocpe:~# echo -n "5" > /debug/picoif/pc3xx_dbg_lvl
+ * root@picocpe:~# cat /debug/picoif/pc3xx_dbg_lvl
+ * 5
+ * root@picocpe:~#
+ * \endcode
+ *
+ * The debug log itself can be read through the /debug/picoif/log file. Note
+ * that reading this file will consume the log and the log itself is not
+ * seekable. The log is implemented as a circular buffer, and if the buffer
+ * fills, the oldest data is discarded to allow new messages to be logged.
+ *
+ * To prevent the debug information from slowing down applications by printing
+ * to the serial console, by default the debug messages won't be printed to
+ * the console. If you do want to send debug messages to the console in
+ * addition to the ring buffer, then DBG_TO_CONSOLE should be defined in
+ * debug.c. To disable this, simply undef it.
+ *
+ * \section addingnewcomponents Adding new debug components
+ *
+ * To add new debug components:
+ *  \li Create a static u8 for the current debug level of the component in
+ *  debug.c
+ *  \li Create a dbg_component in debug.c for the new component.
+ *  \li In pc_debug_create_log_file(), add a debugfs_create_u8() call for the
+ *  new components debug level. This will export the debug level through
+ *  debugfs.
+ *  \li In debug.h, create a new COMPONENT_xxx and corresponding extern
+ *  dbg_component declaration so that the component can be used in the code.
+ *
+ * \section debugfromkernel Printing the debug from kernelspace
+ *
+ * It is also possible to dump the contents of the debug ring buffer from
+ * kernel space. This is achieved with debug_dump().
+ */
+#ifndef __PICOIF_DEBUG_H__
+#define __PICOIF_DEBUG_H__
+
+#include <linux/fs.h>
+
+/*!
+ * \brief Debug component structure. Used so that we can control debug levels
+ * through debugfs and prefix messages with a component name.
+ */
+struct dbg_component
+{
+    u8          *curr_lvl;  /*!< Pointer to the current debug level of the
+                             *   component. */
+    const char  *name;      /*!< The name of the debug component. */
+};
+
+extern struct dbg_component picoif_dbg_component;
+extern struct dbg_component pc202_dbg_component;
+extern struct dbg_component pc3xx_dbg_component;
+extern struct dbg_component axi2cfg_dbg_component;
+extern struct dbg_component gpr_int_dbg_component;
+extern struct dbg_component dma_dbg_component;
+extern struct dbg_component hwif2_dbg_component;
+extern struct dbg_component debug_dbg_component;
+
+/*! Main picoIf debug component. */
+#define COMPONENT_PICOIF    (&picoif_dbg_component)
+/*! PC202 debug component. */
+#define COMPONENT_PC3XX     (&pc3xx_dbg_component)
+/*! AXI2Cfg debug component. */
+#define COMPONENT_AXI2CFG   (&axi2cfg_dbg_component)
+/*! GPR IRQ transport module component. */
+#define COMPONENT_GPR_INT   (&gpr_int_dbg_component)
+/*! DMA transport module component. */
+#define COMPONENT_DMA       (&dma_dbg_component)
+/*! HwIF transport module component. */
+#define COMPONENT_HWIF2     (&hwif2_dbg_component)
+/*! Debug module component. */
+#define COMPONENT_DEBUG     (&debug_dbg_component)
+
+/*! Debug levels for the debug subsystem. Higher numeric values are of lower
+ *  importance. */
+enum dbg_level
+{
+    DBG_ERROR,
+    DBG_WARN,
+    DBG_TRACE,
+    DBG_TRIVIAL,
+};
+
+#undef DBG_SHOW_LOCATION
+
+#ifdef DBG_SHOW_LOCATION
+/*!
+ * Print a debug message if the current debug level is appropriate for the
+ * severity of the debug message.
+ *
+ * @param _component The component to tag the message with.
+ * @param _level The level of the message.
+ * @param _fmt The format string for the message.
+ */
+#define PRINTD( _component, _level, _fmt, ... ) \
+    do { \
+        if ( _level < *( _component->curr_lvl ) ) { \
+            pc_debug_print( _component->name, "%s %u: " _fmt "\n", __FILE__, \
+                            __LINE__, ##__VA_ARGS__ ); \
+        } \
+    } while ( 0 )
+#else /* DBG_SHOW_LOCATION */
+/*!
+ * Print a debug message if the current debug level is appropriate for the
+ * severity of the debug message.
+ *
+ * @param _component The component to tag the message with.
+ * @param _level The level of the message.
+ * @param _fmt The format string for the message.
+ */
+#define PRINTD( _component, _level, _fmt, ... ) \
+    do { \
+        if ( _level < *( _component->curr_lvl ) ) { \
+            pc_debug_print( _component->name, "%s(): " _fmt "\n", \
+                            __FUNCTION__, ##__VA_ARGS__ ); \
+        } \
+    } while ( 0 )
+#endif /* DBG_SHOW_LOCATION */
+
+/*!
+ * Print a debug message into the debug ring.
+ *
+ * @param component The name of the component responsible for the message.
+ * @param fmt The format string for the message.
+ * @return Returns the number of bytes written into the ring.
+ */
+ssize_t pc_debug_print( const char *component,
+                        const char *fmt,
+                        ... );
+
+/*!
+ * Dump the debug ring to the console.
+ */
+void debug_dump( void );
+
+/*!
+ * Create an entry for the picoIf log in debugfs.
+ *
+ * @param parent The directory to create the log file in.
+ * @return Returns a dentry pointer to the log file on success, NULL on
+ * failure.
+ */
+struct dentry *
+pc_debug_create_log_file( struct dentry *parent );
+
+/*!
+ * Destroy the debug ring.
+ */
+void
+pc_debug_close( void );
+
+#endif /* __PICOIF_DEBUG_H__ */
diff --git a/drivers/picochip/directdma.c b/drivers/picochip/directdma.c
new file mode 100644
index 0000000..4a63425
--- /dev/null
+++ b/drivers/picochip/directdma.c
@@ -0,0 +1,461 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file directdma.c
+ * \brief Direct DMA transport module implementation.
+ *
+ * This file implements a simple direct, downlink DMA transport.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/picochip/transports/dma.h>
+#include <linux/picochip/picoif_ioctl.h>
+
+#include "debug.h"
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include "picoif_module.h"
+#include "directdma_internal.h"
+
+/*!
+ * \brief The basic DMA module.
+ * \extends picoif_module
+ */
+struct directdma_module
+{
+    struct picoif_module   mod;            /*!< The generic module. */
+};
+
+struct directdma_ctx;
+
+struct directdma_completion {
+    struct list_head        head;
+    struct directdma_ctx    *ctx;
+    size_t                  nbytes;
+    void                    *cookie;
+};
+
+/*!
+ * \brief DMA channel parameters (one per DMA channel).
+ */
+struct directdma_ctx
+{
+    struct picoarray        *pa;            /*!< The picoArray running the
+                                             *   transport. */
+    struct pico_resource    *chan;          /*!< DMA channel */
+    unsigned                channel_active; /*!< Boolean defining channel
+                                             *   status */
+    spinlock_t              lock;           /*!< DMA channel lock */
+    struct scatterlist      *sg;            /*!< The next scatterlist to
+                                             *   transfer so we can do true
+                                             *   scatterlists rather than
+                                             *   single entries. */
+    size_t                  bytes_complete; /*!< The number of bytes
+                                             *   transferred. */
+    void                    *cookie;        /*!< The completion cookie. */
+    void                    ( *callback )( size_t nbytes,
+                                           void *cookie );
+    struct list_head        completed;      /*!< The completed xfers. */
+    struct tasklet_struct   complete_task;  /*!< The task to call completions.*/
+};
+
+static void
+directdma_destructor( struct picoif_module *module );
+
+static struct picoif_context *
+directdma_create_trans_instance( struct picoif_module *module,
+                                 const char *description,
+                                 struct picoif_buf *params );
+
+static void
+directdma_close_trans_instance( struct picoif_module *module,
+                                struct picoif_context *ctx );
+
+static ssize_t
+directdma_writesg( struct picoif_module *module,
+                   struct picoif_context *ctx,
+                   struct scatterlist *sgl,
+                   unsigned n_ents,
+                   void *cookie );
+
+static int
+directdma_can_write( struct picoif_module *module,
+                     struct picoif_context *ctx )
+{
+    return -EOPNOTSUPP;
+}
+
+static ssize_t
+directdma_write( struct picoif_module *module,
+                 struct picoif_context *ctx,
+                 struct picoif_buf *data,
+                 size_t len )
+{
+    return -EOPNOTSUPP;
+}
+
+static int
+directdma_can_read( struct picoif_module *module,
+                    struct picoif_context *ctx )
+{
+    return -EOPNOTSUPP;
+}
+
+static ssize_t
+directdma_read( struct picoif_module *module,
+                struct picoif_context *ctx,
+                struct picoif_buf *data,
+                size_t len )
+{
+    return -EOPNOTSUPP;
+}
+
+/*! picoIf module operations for the DMA module. */
+static struct picoif_module_ops directdma_ops = {
+    .destructor             = directdma_destructor,
+    .create_trans_instance  = directdma_create_trans_instance,
+    .close_instance         = directdma_close_trans_instance,
+    .writesg                = directdma_writesg,
+    .write                  = directdma_write,
+    .can_write              = directdma_can_write,
+    .read                   = directdma_read,
+    .can_read               = directdma_can_read,
+};
+
+/*! Transport methods for the DMA transport module */
+static const char *directdma_tmethods[] = {
+    "dl",
+    NULL,
+};
+
+/*! The DMA transport */
+static struct directdma_module directdma_mod ={
+    .mod = {
+        .name       = "directdma",
+        .tmethods   = directdma_tmethods,
+        .ops        = &directdma_ops,
+    },
+};
+
+static void
+directdma_complete( unsigned long param )
+{
+    struct directdma_ctx *channel = ( struct directdma_ctx * )param;
+    struct directdma_completion *pos, *tmp;
+    LIST_HEAD( completed );
+
+    spin_lock_bh( &channel->lock );
+    list_splice_init( &channel->completed, &completed );
+    spin_unlock_bh( &channel->lock );
+
+    list_for_each_entry_safe( pos, tmp, &completed, head )
+    {
+        list_del( &pos->head );
+        channel->callback( pos->nbytes, pos->cookie );
+        kfree( pos );
+    }
+}
+
+static size_t
+sg_length( struct scatterlist *sgl )
+{
+    struct scatterlist *pos = sgl;
+    size_t nbytes = 0;
+
+    while ( pos )
+    {
+        nbytes += pos->length;
+        pos = sg_next( pos );
+    }
+
+    return nbytes;
+}
+
+/*!
+ * Handler function for interrupts called by a completed DMA transfer.
+ *
+ * @param cookie The channel associated with the interrupt source.
+ * @param errno The error number associated with the DMA transfer
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+dma_handler( void *cookie,
+             int errno )
+{
+    struct directdma_ctx *channel = cookie;
+    int ret = 0;
+    struct directdma_completion *comp;
+    size_t nbytes;
+
+    if ( errno )
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR,"DMA transfer generated "
+                "error %d (cookie=0x%p)", errno, cookie );
+        channel->channel_active = 0;
+        return errno;
+    }
+
+    spin_lock_bh( &channel->lock );
+
+    nbytes = sg_length( channel->sg );
+    PRINTD( COMPONENT_DMA, DBG_TRACE, "transfer of %zu bytes complete",
+            nbytes );
+
+    comp = kmalloc( sizeof( *comp ), GFP_ATOMIC );
+    if ( comp )
+    {
+        PRINTD( COMPONENT_DMA, DBG_TRACE, "sg dma complete, schedule tasklet" );
+        comp->nbytes = nbytes;
+        comp->cookie = channel->cookie;
+        list_add_tail( &comp->head, &channel->completed );
+        tasklet_schedule( &channel->complete_task );
+    }
+    else
+        ret = -ENOMEM;
+
+    channel->channel_active = 0;
+
+    spin_unlock_bh( &channel->lock );
+
+    return ret;
+}
+
+/*!
+ * Write to the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param sgl The data to write.
+ * @param n_ents The number of entries in the scatterlist.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+static ssize_t
+directdma_writesg( struct picoif_module *module,
+                   struct picoif_context *ctx,
+                   struct scatterlist *sgl,
+                   unsigned n_ents,
+                   void *cookie )
+{
+    struct directdma_ctx *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+    int ret = 0;
+
+    /* Start a DMA transfer */
+    spin_lock( &channel->lock );
+
+    if ( !channel->channel_active )
+    {
+        int tmp = 0;
+
+        channel->channel_active = 1;
+        channel->sg             = sgl;
+        channel->cookie         = cookie;
+        channel->bytes_complete = 0;
+
+        PRINTD( COMPONENT_DMA, DBG_TRACE, "start transfer of %zu bytes",
+                channel->sg->length );
+
+	tmp = pa->ops->dma_to_device( pa, channel->chan, sgl, n_ents,
+				      dma_handler, channel );
+        if ( tmp < 0)
+            ret = tmp;
+    }
+    else
+    {
+        ret = -EBUSY;
+    }
+
+    spin_unlock( &channel->lock );
+
+    return ret;
+}
+
+/*!
+ * Destructor for the DMA module.
+ *
+ * @param module The module being destroyed.
+ */
+static void
+directdma_destructor( struct picoif_module *module )
+{
+}
+
+/*!
+ * Create a and start the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param description The type of transport to create.
+ * @param params Extra parameters for the transport type.
+ * @return Returns the transport context on success, or an ERR_PTR on failure.
+ */
+static struct picoif_context *
+directdma_create_trans_instance( struct picoif_module *module,
+                                 const char *description,
+                                 struct picoif_buf *params )
+{
+    int ret = -ENOMEM;
+    void *private_data = NULL;
+    struct picoif_context *ctx = picoif_new_ctx( module, private_data );
+    struct picoif_directdma_params gparams;
+    struct picoarray *pa = NULL;
+    struct directdma_ctx *channel;
+    struct pico_resource *chan = NULL;
+
+    ret = picoif_buf_copy_from( &gparams, params, 0,
+                                sizeof( gparams ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    pa = picoif_get_device( gparams.dev_num );
+    if ( !pa )
+    {
+        PRINTD( COMPONENT_DMA, DBG_WARN, "invalid device number: %u",
+                gparams.dev_num );
+        goto out;
+    }
+
+    /* Check that the DMA channel is not already in use */
+    ret = -EBUSY;
+    chan = pa->ops->get_resource( pa, PICO_RES_DMA_CHANNEL,
+                                             gparams.channel, 1 );
+    if ( !chan )
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR, "invalid DMA channel:%u",
+                gparams.channel );
+        goto out;
+    }
+
+    if ( !ctx )
+        goto out;
+
+    /* Allocate the new channel and initialise the data members. */
+    ret = -ENOMEM;
+    channel = kmalloc( sizeof( *channel ), GFP_KERNEL );
+    if (!channel)
+        goto out;
+    ctx->private_data = channel;
+
+    spin_lock_init( &channel->lock );
+
+    channel->channel_active = 0;
+    channel->pa             = pa;
+    channel->chan           = chan;
+    channel->callback       = gparams.callback;
+    tasklet_init( &channel->complete_task, directdma_complete,
+                  ( unsigned long )channel );
+    INIT_LIST_HEAD( &channel->completed );
+
+    if ( strcmp( description, "directdma(dl)" ) )
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR, "invalid tmethod \"%s\"",
+                description );
+        ret = -EINVAL;
+        goto bad_description;
+    }
+
+    ret = pa->ops->dma_open( pa, chan );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR, "failed to open DMA channel" );
+        goto bad_description;
+    }
+
+    ret = 0;
+    goto out;
+
+bad_description:
+    kfree( channel );
+
+out:
+    if ( ret )
+    {
+        kfree( ctx );
+        if ( chan )
+            pa->ops->put_resource(  pa, chan );
+    }
+
+    return ret ? ERR_PTR( ret ) : ctx;
+}
+
+/*!
+ * Close an existing transport instance.
+ *
+ * @param mod The module handling the transport.
+ * @param ctx The context that is being closed.
+ */
+static void
+directdma_close_trans_instance( struct picoif_module *mod,
+                                struct picoif_context *ctx )
+{
+    struct directdma_ctx *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+    (void)pa->ops->dma_close( pa, channel->chan );
+
+    pa->ops->put_resource( pa, channel->chan );
+
+    if ( channel )
+    {
+        kfree( channel );
+        channel = NULL;
+    }
+
+    if ( ctx )
+    {
+        kfree( ctx );
+        ctx = NULL;
+    }
+}
+
+/* Kernel API and Public functions */
+struct picoif_context *
+picoif_directdma_open( unsigned dev_num,
+                       int dma_chan,
+                       void ( *callback )( size_t nbytes,
+                                           void *cookie ) )
+{
+    struct picoif_directdma_params dma_params = {
+        .dev_num    = dev_num,
+        .channel    = dma_chan,
+        .callback   = callback,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &dma_params,
+        .is_user    = 0,
+    };
+
+    struct picoif_context *ctx =
+        directdma_create_trans_instance( &directdma_mod.mod,
+                                         "directdma(dl)", &buf );
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_directdma_open );
+
+int
+directdma_init( void )
+{
+    return picoif_register_module( &directdma_mod.mod );
+}
diff --git a/drivers/picochip/directdma_internal.h b/drivers/picochip/directdma_internal.h
new file mode 100644
index 0000000..5dbac7d
--- /dev/null
+++ b/drivers/picochip/directdma_internal.h
@@ -0,0 +1,34 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2010 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file directdma_internal.h
+ * \brief Initialisation function for Direct DMA transport.
+ *
+ * Internal Direct DMA transport function definitions
+ *
+ */
+
+#ifndef __PICOIF_DIRECTDMA_INTERNAL_H__
+#define __PICOIF_DIRECTDMA_INTERNAL_H__
+
+/*!
+ * Initialise the direct DMA transport.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+directdma_init( void );
+
+#endif /* !__PICOIF_DIRECTDMA_INTERNAL_H__ */
diff --git a/drivers/picochip/dma.c b/drivers/picochip/dma.c
new file mode 100644
index 0000000..e4da6e2
--- /dev/null
+++ b/drivers/picochip/dma.c
@@ -0,0 +1,793 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma.c
+ * \brief DMA transport module implementation.
+ *
+ * This file implements Basic DMA transports.
+ *
+ * Two transport methods are provided:
+ *   \li dma1(dl)
+ *   \li dma1(ul)
+ *
+ * The "dl" transport is the main mechanism for loading data into the picoArray
+ * using DMA channels.
+ * The "ul" transport is for debugging purposesi only, as a transfer from the
+ * picoArray to the host only occurs if the host requests the transfer.
+ * In both methods the DMA engine is used to perform the transfer which calls
+ * the an interrupt handler on exit. This handler will update the FIFO pointers
+ * and wake up any sleeping processes.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/picochip/transports/dma.h>
+#include <linux/picochip/picoif_ioctl.h>
+
+#include "debug.h"
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include "picoif_module.h"
+#include "dma_internal.h"
+#include "dma_fifo_internal.h"
+
+/*!
+ * \brief The basic DMA module.
+ * \extends picoif_module
+ */
+struct dma_module
+{
+    struct picoif_module   mod;            /*!< The generic module. */
+};
+
+/*!
+ * \brief DMA channel parameters (one per DMA channel).
+ */
+static struct dma_channel
+{
+    struct picoarray *pa;             /*!< The picoArray running the
+                                       *   transport. */
+    struct picoif_context *reader;    /*!< The reader of the channel. */
+    unsigned isDownlink;              /*!< Boolean defining DMA direction */
+    struct pico_resource *chan;       /*!< DMA channel */
+    unsigned channelActive;           /*!< Boolean defining channel status */
+    unsigned xfer_size;               /*!< Size of transfer in bytes */
+    unsigned max_transfer_size;       /*!< Max transfer size in bytes */
+    struct kfifo *fifo;               /*!< DMA FIFO for this channel */
+    spinlock_t lock;                  /*!< DMA channel lock */
+    struct scatterlist sgl[2];        /*!< Transfer scatterlist. */
+    int nents;                        /*!< Number of scatterlist entries. */
+    struct tasklet_struct tasklet;    /*!< Tasklet for new xfers. */
+}
+dma_channel;
+
+static void
+dma_destructor( struct picoif_module *module );
+
+static struct picoif_context *
+dma_create_trans_instance( struct picoif_module *module,
+                           const char *description,
+                           struct picoif_buf *params );
+
+static void
+dma_close_trans_instance( struct picoif_module *module,
+                          struct picoif_context *ctx );
+
+static ssize_t
+dma_write( struct picoif_module *module,
+           struct picoif_context *ctx,
+           struct picoif_buf *buf,
+           size_t len );
+
+static ssize_t
+dma_read( struct picoif_module *module,
+          struct picoif_context *ctx,
+          struct picoif_buf *buf,
+          size_t len );
+
+static int
+dma_can_write( struct picoif_module *module,
+               struct picoif_context *ctx );
+
+static int
+dma_can_read( struct picoif_module *module,
+              struct picoif_context *ctx );
+
+static ssize_t
+dma_writev( struct picoif_module *module,
+            struct picoif_context *ctx,
+            const struct iovec *vecs,
+            unsigned nr_segs,
+            int from_user );
+
+/*! picoIf module operations for the DMA module. */
+static struct picoif_module_ops dma_ops = {
+    .destructor             = dma_destructor,
+    .create_trans_instance  = dma_create_trans_instance,
+    .close_instance         = dma_close_trans_instance,
+    .write                  = dma_write,
+    .read                   = dma_read,
+    .can_read               = dma_can_read,
+    .can_write              = dma_can_write,
+    .writev                 = dma_writev,
+};
+
+/*! Transport methods for the DMA transport module */
+static const char *dma_tmethods[] = {
+    "dl",
+    "ul",
+};
+
+/*! The DMA transport */
+static struct dma_module dma_mod ={
+    .mod = {
+        .name       = "dma1",
+        .tmethods   = dma_tmethods,
+        .ops        = &dma_ops,
+    },
+};
+
+/*!
+ * Check if the transport can be written to.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return Returns 1 if the transport can be written, 0 otherwise
+ * 0.
+ */
+static int
+dma_can_write( struct picoif_module *module,
+               struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    unsigned fifo_space = kfifo_avail( channel->fifo );
+    int ret = 1;
+
+    spin_lock_bh( &channel->lock );
+    if ( !channel->isDownlink && !channel->channelActive )
+    {
+        ret = 1; /* Transfer size requests permitted in the UL */
+        goto out;
+    }
+
+    if ( !fifo_space || channel->channelActive )
+    {
+        ret = 0; /* No space in FIFO or transfer is in progress. */
+        goto out;
+    }
+
+out:
+    spin_unlock_bh( &channel->lock );
+    return ret;
+}
+
+/*!
+ * Check if the transport can be read from.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return Returns 1 if the transport can be read, 0 otherwise.
+ */
+static int
+dma_can_read( struct picoif_module *module,
+              struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    if ( channel->isDownlink )
+        return 0;  /* Cannot read from a downlink */
+
+    return kfifo_len( channel->fifo ) ? 1 : 0;
+}
+
+static void
+__dma_push_fifo( struct dma_channel *channel );
+
+static void
+dma_tasklet( unsigned long param )
+{
+    struct dma_channel *channel = ( struct dma_channel * )param;
+
+    __dma_push_fifo( channel );
+}
+
+/*!
+ * Handler function for interrupts called by a completed DMA transfer.
+ *
+ * @param cookie The channel associated with the interrupt source.
+ * @param errno The error number associated with the DMA transfer
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+dma_handler( void *cookie,
+             int errno )
+{
+    struct dma_channel *channel = cookie;
+    int ret = 0;
+
+    BUG_ON( NULL == cookie );
+
+    if ( errno )
+    {
+       PRINTD( COMPONENT_DMA, DBG_ERROR,"DMA transfer generated "
+          "error %d (cookie=0x%p)", errno, cookie );
+       channel->channelActive = 0;
+       return errno;
+    }
+
+    channel->channelActive = 0;
+
+    if ( channel->isDownlink )
+    {
+        PRINTD( COMPONENT_DMA, DBG_TRACE,"DL transfer of %d bytes completed",
+            channel->xfer_size );
+
+        /* Update the FIFO ptrs to indicate more data available */
+        kfifo_dma_out_finish( channel->fifo, channel->xfer_size );
+        dma_unmap_sg( NULL, channel->sgl, channel->nents, DMA_TO_DEVICE );
+        wake_up_interruptible( &channel->reader->writeq );
+
+        tasklet_schedule( &channel->tasklet );
+    }
+    else
+    {
+        PRINTD( COMPONENT_DMA, DBG_TRACE,"UL transfer of %d bytes completed",
+            channel->xfer_size );
+
+        /* Add data transferred to FIFO control parameters */
+        kfifo_dma_in_finish( channel->fifo, channel->xfer_size );
+        dma_unmap_sg( NULL, channel->sgl, channel->nents, DMA_FROM_DEVICE );
+        wake_up_interruptible( &channel->reader->readq );
+    }
+
+    return ret;
+}
+
+static void
+__dma_push_fifo( struct dma_channel *channel )
+{
+    struct picoarray *pa = channel->pa;
+    size_t len;
+    int ret;
+
+    if ( channel->channelActive )
+        return;
+
+    len = kfifo_len( channel->fifo ) & ~0x3;
+    if ( len > channel->max_transfer_size )
+        len = channel->max_transfer_size;
+
+    sg_init_table( channel->sgl, 2 );
+    channel->nents = kfifo_dma_out_prepare( channel->fifo, channel->sgl,
+                                            2, len );
+    channel->nents = dma_map_sg( NULL, channel->sgl, channel->nents,
+                                 DMA_TO_DEVICE );
+    channel->xfer_size = len;
+
+    if ( len )
+    {
+        PRINTD( COMPONENT_DMA, DBG_TRACE, "start DL transfer of %zu bytes",
+                channel->xfer_size );
+        channel->channelActive = 1;
+        ret = pa->ops->dma_to_device( pa, channel->chan, channel->sgl,
+                                      channel->nents, dma_handler,
+                                      channel );
+        if ( ret )
+            PRINTD( COMPONENT_PC3XX, DBG_WARN,
+                    "failed to start DMA to device" );
+    }
+}
+
+static void
+dma_push_fifo( struct dma_channel *channel )
+{
+    spin_lock_bh( &channel->lock );
+    __dma_push_fifo( channel );
+    spin_unlock_bh( &channel->lock );
+}
+
+/*!
+ * Write to the DMA downlink transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param buf The data to be written.
+ * @param len The length of data to be written in bytes.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+static ssize_t
+dma_write_downlink( struct dma_channel *channel,
+                    struct picoif_buf *buf,
+                    size_t len )
+{
+    int ret=0;
+
+    /* Add data to FIFO (assuming there is room) */
+    ret = dma_fifo_put( channel->fifo, buf, len );
+    if ( ret < 0 )
+        goto out;
+
+    if ( 0 == ret )
+    {
+        ret = -EAGAIN;
+        goto out;
+    }
+
+    PRINTD( COMPONENT_DMA, DBG_TRACE, "write %u bytes (requested %u bytes)",
+            ret, len );
+
+    dma_push_fifo( channel );
+
+out:
+    return ret;
+}
+
+/*!
+ * Write to the uplink DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param buf The data to be written.
+ * @param len The length of data to be transfers in bytes.
+ * @return Returns the size of the DMA transfer requested on success,
+ * negative on failure.
+ */
+static ssize_t
+dma_write_uplink( struct dma_channel *channel,
+                  struct picoif_buf *buf,
+                  size_t len )
+{
+    struct picoarray *pa = channel->pa;
+    int ret=0;
+    unsigned size = 0;
+
+    if ( len != sizeof( uint32_t )  )
+        return -EINVAL;
+
+    if ( channel->channelActive )
+        return -EAGAIN;
+
+    spin_lock_bh( &channel->lock );
+
+    ret = picoif_buf_copy_from( &size, buf, 0, sizeof( uint32_t ) );
+    if ( ret )
+        goto out;
+
+    if ( channel->channelActive )
+    {
+        ret = -EAGAIN;
+        goto out;
+    }
+
+    /* Start a DMA transfer */
+    channel->xfer_size = kfifo_avail( channel->fifo );
+    if ( size < channel->xfer_size )
+       channel->xfer_size = size;
+
+    /* Ensure that transfers requests are multiplies of 4 bytes */
+    channel->xfer_size &= ~0x03ul;
+    if ( channel->xfer_size > channel->max_transfer_size )
+        channel->xfer_size = channel->max_transfer_size;
+
+    if ( channel->xfer_size < size )
+    {
+        ret = -EAGAIN;
+        goto out;
+    }
+
+    if ( channel->xfer_size )
+    {
+        sg_init_table( channel->sgl, 2 );
+        channel->nents = kfifo_dma_in_prepare( channel->fifo, channel->sgl, 1,
+                                               channel->xfer_size );
+        channel->nents = dma_map_sg( NULL, channel->sgl, channel->nents,
+                                     DMA_FROM_DEVICE );
+
+        PRINTD( COMPONENT_DMA, DBG_TRACE, "request a transfer of %u bytes)",
+                channel->xfer_size );
+
+        ret = ( pa->ops->dma_from_device( pa, channel->chan, channel->sgl,
+                                          channel->nents, dma_handler,
+                                          channel ));
+        if ( ret )
+            PRINTD( COMPONENT_DMA, DBG_WARN,
+                    "failed to start transfer from device" );
+        if ( !ret )
+            ret = channel->xfer_size;
+    }
+
+out:
+    spin_unlock_bh( &channel->lock );
+
+    return ret;
+}
+
+/*!
+ * Write to the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param buf The data to be written.
+ * @param len The length of data to be written in bytes.
+ * @return Returns the number of bytes written (downlink) or
+ * the size of the DMA request (uplink) on success, negative on
+ * failure.
+ */
+static ssize_t
+dma_write( struct picoif_module *module,
+           struct picoif_context *ctx,
+           struct picoif_buf *buf,
+           size_t len )
+{
+    struct dma_channel *channel = ctx->private_data;
+    int ret = 0;
+
+    if ( channel->isDownlink )
+    {
+        ret = dma_write_downlink( channel, buf, len );  
+    }
+    else
+    {
+        ret = dma_write_uplink( channel, buf, len );
+    }
+
+    return ret;
+}
+
+/*!
+ * Vectored write to the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param vecs The vectors of data to write into the transport.
+ * @param nr_segs The number of entries in the IO vector.
+ * @param from_user Boolean flag to indicate that the vectors point to
+ * userspace buffers and must be copied across the address spaces.
+ * @return Returns the number of bytes written into the transport on
+ * success, negative on failure.
+ * failure.
+ */
+static ssize_t
+dma_writev( struct picoif_module *module,
+            struct picoif_context *ctx,
+            const struct iovec *vecs,
+            unsigned nr_segs,
+            int from_user )
+{
+    struct dma_channel *channel = ctx->private_data;
+    ssize_t ret = 0;
+    unsigned seg = 0;
+    ssize_t len = 0;
+    unsigned bytes_queued = 0;
+
+    PRINTD( COMPONENT_DMA, DBG_TRACE, "received a vector write of %u segments",
+         nr_segs);
+
+    /* Check that the total length of the transfer is a multiple of 4 bytes */
+    for ( seg = 0; seg < nr_segs; ++seg )
+        len += vecs[seg].iov_len;
+
+    for ( seg = 0; seg < nr_segs; ++seg )
+    {
+        struct picoif_buf buf = {
+            .ubuf       = ( char __user * )vecs[ seg ].iov_base,
+            .is_user    = 1,
+        };
+
+        ret = dma_fifo_put( channel->fifo, &buf, vecs[seg].iov_len );
+        if ( ret < 0 )
+            goto out;
+
+        bytes_queued += ret;
+
+        if ( ret < vecs[seg].iov_len )
+            break;
+    }
+
+    ret = bytes_queued;
+    if ( !ret )
+        return -EAGAIN;
+
+    PRINTD( COMPONENT_DMA, DBG_TRACE, "vector write %u bytes (requested %u bytes)",
+              ret, len );
+
+    dma_push_fifo( channel );
+
+out:
+
+    return ret;
+}
+
+/*!
+ * Read from the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the read.
+ * @param buf The buffer to write the data into.
+ * @param len The number of bytes requested to read.
+ * @return Returns the number of bytes read on success, negative on failure.
+ */
+static ssize_t
+dma_read( struct picoif_module *module,
+          struct picoif_context *ctx,
+          struct picoif_buf *buf,
+          size_t len )
+{
+    struct dma_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+    int ret = 0;
+    unsigned used_bytes=0;
+
+    /* Determine how much data is already in the FIFO */
+    used_bytes = kfifo_len( channel->fifo );
+
+    spin_lock_bh( &channel->lock );
+    /* Not enough data in the FIFO - request a transfer */
+    if ( used_bytes > 3 && used_bytes < len && ( !channel->channelActive) )
+    {
+        len = ( len - used_bytes ) & ~0x3;
+        if ( len > channel->max_transfer_size )
+            len = channel->max_transfer_size;
+        sg_init_table( channel->sgl, 2 );
+        channel->nents = kfifo_dma_in_prepare( channel->fifo, channel->sgl, 1,
+                                               len );
+        channel->nents = dma_map_sg( NULL, channel->sgl, channel->nents,
+                                     DMA_FROM_DEVICE );
+        channel->xfer_size = len;
+
+        if ( len )
+        {
+            channel->channelActive = 1;
+            ret = pa->ops->dma_from_device( pa, channel->chan, channel->sgl,
+                                            channel->nents, dma_handler,
+                                            channel );
+            if ( ret )
+                PRINTD( COMPONENT_DMA, DBG_WARN,
+                        "failed to start transfer from device" );
+        }
+    }
+
+    /* Now return any bytes available */
+    if ( !used_bytes )
+    {
+        spin_unlock_bh( &channel->lock );
+        return -EAGAIN;
+    }
+
+    if ( used_bytes > len )
+        used_bytes = len;
+
+    ret = dma_fifo_get( channel->fifo, buf, used_bytes );
+
+    PRINTD( COMPONENT_DMA, DBG_TRACE,
+            "read %u bytes (requested %u bytes)", used_bytes, len );
+
+    if ( !ret )
+        ret = used_bytes;
+
+    spin_unlock_bh( &channel->lock );
+    return ret;
+}
+
+/*!
+ * Destructor for the DMA module.
+ *
+ * @param module The module being destroyed.
+ */
+static void
+dma_destructor( struct picoif_module *module )
+{
+}
+
+/*!
+ * Create a and start the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param description The type of transport to create.
+ * @param params Extra parameters for the transport type.
+ * @return Returns the transport context on success, or an ERR_PTR on failure.
+ */
+static struct picoif_context *
+dma_create_trans_instance( struct picoif_module *module,
+                           const char *description,
+                           struct picoif_buf *params )
+{
+    int ret = -ENOMEM;
+    void *private_data = NULL;
+    struct picoif_context *ctx = picoif_new_ctx( module, private_data );
+    struct picoif_dma_params gparams;
+    struct picoarray *pa = NULL;
+    struct dma_channel *channel;
+    struct pico_resource *chan = NULL;
+
+    ret = picoif_buf_copy_from( &gparams, params, 0,
+                                sizeof( gparams ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    pa = picoif_get_device( gparams.dev_num );
+    if ( !pa )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "invalid device number: %u",
+                gparams.dev_num );
+        goto out;
+    }
+
+    /* Check that the DMA channel is not already in use */
+    ret = -EBUSY;
+    chan = pa->ops->get_resource( pa, PICO_RES_DMA_CHANNEL,
+                                             gparams.channel, 1 );
+    if ( !chan )
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR, "invalid DMA channel:%u",
+                gparams.channel );
+        goto out;
+    }
+
+   if ( !ctx )
+       goto out;
+
+    /* Allocate the new channel and initialise the data members. */
+    ret = -ENOMEM;
+    channel = kmalloc( sizeof( dma_channel ), GFP_KERNEL );
+    if (!channel)
+        goto out;
+    ctx->private_data = channel;
+
+    channel->fifo = dma_buf_cache_alloc( gparams.buf_size );
+    if ( !channel->fifo )
+        goto bad_fifo_alloc;
+
+    spin_lock_init( &channel->lock );
+
+    channel->reader = ctx;
+    channel->channelActive = 0;
+    channel->pa = pa;
+    channel->chan = chan;
+    channel->max_transfer_size = pa->max_dma_sz;
+    tasklet_init( &channel->tasklet, dma_tasklet, ( unsigned long )channel );
+
+    if ( !strcmp( description, "dma1(dl)" ) )
+        channel->isDownlink = 1;
+    else if ( !strcmp( description, "dma1(ul)" ) )
+        channel->isDownlink = 0;
+    else
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR, "invalid tmethod \"%s\"",
+                description );
+        ret = -EINVAL;
+        goto bad_description;
+    }
+
+    ret = pa->ops->dma_open( pa, chan );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_DMA, DBG_ERROR, "failed to open DMA channel" );
+        goto bad_description;
+    }
+
+    ret = 0;
+    goto out;
+
+bad_description:
+   dma_buf_cache_free( channel->fifo );
+
+bad_fifo_alloc:
+    kfree( channel );
+
+out:
+    if ( ret )
+    {
+        kfree( ctx );
+        if ( chan )
+            pa->ops->put_resource(  pa, chan );
+    }
+
+    return ret ? ERR_PTR( ret ) : ctx;
+}
+
+/*!
+ * Close an existing transport instance.
+ *
+ * @param mod The module handling the transport.
+ * @param ctx The context that is being closed.
+ */
+static void
+dma_close_trans_instance( struct picoif_module *mod,
+                          struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+    (void)pa->ops->dma_close( pa, channel->chan );
+
+    tasklet_disable( &channel->tasklet );
+    tasklet_kill( &channel->tasklet );
+    pa->ops->put_resource( pa, channel->chan );
+    dma_buf_cache_free( channel->fifo );
+
+    if ( channel )
+    {
+        kfree( channel );
+        channel = NULL;
+    }
+
+    if ( ctx )
+    {
+        kfree( ctx );
+        ctx = NULL;
+    }
+}
+
+/* Kernel API and Public functions */
+struct picoif_context *
+picoif_dma_open_dl( unsigned dev_num,
+                    int dma_chan,
+                    size_t buf_size )
+{
+    struct picoif_dma_params dma_params = {
+        .dev_num    = dev_num,
+        .channel    = dma_chan,
+        .buf_size   = buf_size,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &dma_params,
+        .is_user    = 0,
+    };
+
+    struct picoif_context *ctx =
+        dma_create_trans_instance( &dma_mod.mod,
+                                       "dma1(dl)", &buf );
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_dma_open_dl );
+
+struct picoif_context *
+picoif_dma_open_ul( unsigned dev_num,
+                    int dma_chan,
+                    size_t buf_size )
+{
+    struct picoif_dma_params dma_params = {
+        .dev_num    = dev_num,
+        .channel    = dma_chan,
+        .buf_size   = buf_size,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &dma_params,
+        .is_user    = 0,
+    };
+    struct picoif_context *ctx =
+        dma_create_trans_instance( &dma_mod.mod,
+                                       "dma1(ul)", &buf );
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_dma_open_ul );
+
+int
+dma_init( void )
+{
+    return picoif_register_module( &dma_mod.mod );
+}
+
+
diff --git a/drivers/picochip/dma_fifo.c b/drivers/picochip/dma_fifo.c
new file mode 100644
index 0000000..d24e784
--- /dev/null
+++ b/drivers/picochip/dma_fifo.c
@@ -0,0 +1,211 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma_fifo.c
+ * \brief Main file for the common DMA FIFO functions
+ *
+ * This file implements the DMA FIFO managing for all transports concerned with
+ * the picoArray.
+ */
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/kfifo.h>
+#include <linux/log2.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/random.h>
+
+#include "picoif_module.h"
+#include "dma_fifo_internal.h"
+
+/*! The maximum number of bytes that can be copied to user in a single
+ *  transfer */
+#define DMA_MAX_TRANSFER_SIZE ( 4096 )
+
+#define DMA_BUF_CACHE_NR_LINES 8
+
+struct dma_buf_cache_line {
+    struct kfifo                *fifo;
+};
+
+struct dma_buf_cache {
+    unsigned long               present;
+    unsigned long               in_use;
+    struct dma_buf_cache_line   lines[DMA_BUF_CACHE_NR_LINES];
+    spinlock_t                  lock;
+};
+
+static struct dma_buf_cache dma_buf_cache = {
+    .lock = __SPIN_LOCK_UNLOCKED(.lock),
+};
+
+void
+dma_buf_cache_exit( void )
+{
+    int i;
+
+    for_each_set_bit( i, &dma_buf_cache.present, DMA_BUF_CACHE_NR_LINES )
+    {
+        struct dma_buf_cache_line *line = &dma_buf_cache.lines[ i ];
+        kfifo_free( line->fifo );
+        kfree( line->fifo );
+    }
+}
+
+static void
+dma_buf_cache_fill( struct kfifo *fifo )
+{
+    int i;
+    struct dma_buf_cache_line *line;
+
+    /*
+     * See if we can find an empty cache line first. If not, evict one from
+     * the cache. Use a random replacement policy.
+     */
+    i = find_first_zero_bit( &dma_buf_cache.present, DMA_BUF_CACHE_NR_LINES );
+    if ( i >= DMA_BUF_CACHE_NR_LINES )
+        i = random32() % DMA_BUF_CACHE_NR_LINES;
+
+    line = &dma_buf_cache.lines[ i ];
+
+    line->fifo = fifo;
+
+    set_bit( i, &dma_buf_cache.in_use );
+    set_bit( i, &dma_buf_cache.present );
+}
+
+struct kfifo *
+dma_buf_cache_alloc( size_t len )
+{
+    int i;
+    unsigned long flags;
+    struct kfifo *ret = NULL;
+    struct dma_buf_cache_line *line;
+
+    len = roundup_pow_of_two( len );
+
+    spin_lock_irqsave( &dma_buf_cache.lock, flags );
+
+    for_each_set_bit( i, &dma_buf_cache.present, DMA_BUF_CACHE_NR_LINES )
+    {
+        /* Don't allocate from lines already in use. */
+        if ( test_bit( i, &dma_buf_cache.in_use ) )
+            continue;
+
+        line = &dma_buf_cache.lines[ i ];
+
+        if ( kfifo_size( line->fifo ) == len )
+        {
+            set_bit( i, &dma_buf_cache.in_use );
+            ret = line->fifo;
+            kfifo_reset( line->fifo );
+
+            goto out;
+        }
+    }
+
+    spin_unlock_irqrestore( &dma_buf_cache.lock, flags );
+
+    /*
+     * We haven't been able to reuse a cache line, allocate a new buffer and
+     * evict an existing line from the cache.
+     */
+    ret = kzalloc( sizeof( *ret ), GFP_KERNEL | GFP_DMA );
+    if ( !ret )
+        goto out;
+
+    if ( kfifo_alloc( ret, len, GFP_KERNEL | GFP_DMA ) )
+        goto err_alloc;
+
+    spin_lock_irqsave( &dma_buf_cache.lock, flags );
+
+    dma_buf_cache_fill( ret );
+
+    goto out;
+
+err_alloc:
+    kfree( ret );
+    ret = NULL;
+out:
+    spin_unlock_irqrestore( &dma_buf_cache.lock, flags );
+
+    return ret;
+}
+
+void
+dma_buf_cache_free( struct kfifo *fifo )
+{
+    int i;
+    unsigned long flags;
+
+    spin_lock_irqsave( &dma_buf_cache.lock, flags );
+
+    for ( i = 0; i < DMA_BUF_CACHE_NR_LINES; ++i )
+    {
+        struct dma_buf_cache_line *line;
+
+        if ( !test_bit( i, &dma_buf_cache.present ) )
+            continue;
+
+        line = &dma_buf_cache.lines[ i ];
+        if ( line->fifo != fifo )
+            continue;
+
+        clear_bit( i, &dma_buf_cache.in_use );
+        spin_unlock_irqrestore( &dma_buf_cache.lock, flags );
+
+        return;
+    }
+
+    spin_unlock_irqrestore( &dma_buf_cache.lock, flags );
+
+    /* The buffer isn't in the cache any more. */
+    kfifo_free( fifo );
+    kfree( fifo );
+}
+
+int
+dma_fifo_put( struct kfifo *fifo,
+              struct picoif_buf *buf,
+              size_t len )
+{
+    unsigned copied = 0;
+    int err = 0;
+
+    if ( buf->is_user )
+        err = kfifo_from_user( fifo, buf->ubuf, len, &copied );
+    else
+        copied = kfifo_in( fifo, buf, len );
+
+    return err ?: ( int )copied;
+}
+
+int
+dma_fifo_get( struct kfifo *fifo,
+              struct picoif_buf *buf,
+              size_t len )
+{
+    unsigned copied = 0;
+    int err = 0;
+
+    if ( buf->is_user )
+        err = kfifo_to_user( fifo, buf->ubuf, len, &copied );
+    else
+        copied = kfifo_out( fifo, buf, len );
+
+    return err ?: ( int )copied;
+}
diff --git a/drivers/picochip/dma_fifo_internal.h b/drivers/picochip/dma_fifo_internal.h
new file mode 100644
index 0000000..7155eb0
--- /dev/null
+++ b/drivers/picochip/dma_fifo_internal.h
@@ -0,0 +1,80 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma_fifo_internal.h
+ * \brief Common DMA FIFO managing functions
+ *
+ * This file contains common functions for managing the DMA FIFOs.
+ */
+
+#ifndef __PICOIF_DMA_FIFO_INTERNAL__
+#define __PICOIF_DMA_FIFO_INTERNAL__
+
+#include <linux/kfifo.h>
+
+#include "picoif_internal.h"
+
+/*!
+ * Cleanup the DMA buffer cache at module exit.
+ */
+void
+dma_buf_cache_exit( void );
+
+/*!
+ * Allocate a DMA fifo from a DMA fifo cache.
+ *
+ * @param len The length of the fifo in bytes.
+ * @return Returns a pointer to the fifo on success.
+ */
+struct kfifo *
+dma_buf_cache_alloc( size_t len );
+
+/*!
+ * Free an existing DMA fifo. If this is still in the cache then it will be
+ * available for reuse. If not then it will be released back to the kernel
+ * memory manager.
+ *
+ * @param fifo The fifo to free.
+ */
+void
+dma_buf_cache_free( struct kfifo *fifo );
+
+/*!
+ * Add some data to the fifo.
+ *
+ * @fifo The fifo to add the data to.
+ * @buf The buffer to add the data from.
+ * @len The number of bytes to add.
+ * @return Returns the number of bytes added on success, negative on failure.
+ */
+int
+dma_fifo_put( struct kfifo *fifo,
+              struct picoif_buf *buf,
+              size_t len );
+
+/*!
+ * Get some data from the fifo.
+ *
+ * @fifo The fifo to get the data from.
+ * @buf The buffer to add the data to.
+ * @len The number of bytes to copy.
+ * @return Returns the number of bytes copied on success, negative on failure.
+ */
+int
+dma_fifo_get( struct kfifo *fifo,
+              struct picoif_buf *buf,
+              size_t len );
+
+#endif /* !__PICOIF_DMA_FIFO_INTERNAL__ */
diff --git a/drivers/picochip/dma_internal.h b/drivers/picochip/dma_internal.h
new file mode 100644
index 0000000..85cb970
--- /dev/null
+++ b/drivers/picochip/dma_internal.h
@@ -0,0 +1,34 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma_internal.h
+ * \brief Initialisation function for DMA transport.
+ *
+ * Internal DMA transport function definitions
+ *
+ */
+
+#ifndef __PICOIF_DMA_INTERNAL_H__
+#define __PICOIF_DMA_INTERNAL_H__
+
+/*!
+ * Initialise the DMA transport.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+dma_init( void );
+
+#endif /* !__PICOIF_DMA_INTERNAL_H__ */
diff --git a/drivers/picochip/gpr_interrupt.c b/drivers/picochip/gpr_interrupt.c
new file mode 100644
index 0000000..7bcd3ef
--- /dev/null
+++ b/drivers/picochip/gpr_interrupt.c
@@ -0,0 +1,536 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file gpr_interrupt.c
+ * \brief GPR interrupt transport module implementation.
+ *
+ * This file implements a GPR based transport mechanism that signals to the
+ * application an interrupt has been generated via a GPR and optionally
+ * records the values of the register at interrupt time.
+ *
+ * The two transport methods provided are:
+ *  \li gpr_interrupt(with_values)
+ *  \li gpr_interrupt(without_values)
+ * The "with_values" variant samples the GPR at interrupt time and maintains a
+ * queue of all of the values at interrupt time. When the transport is read,
+ * an array of the values is returned to the user where each value is 32 bits
+ * and the values are consumed. The "without_values" variant does not record
+ * the value of the GPR at interrupt time (although it does read it to clear
+ * the interrupt). Instead, this method maintains a count of the interrupts
+ * raised and when read, returns the number of interrupts raised encoded in
+ * the first 4 bytes of the buffer and the count is set to 0.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/picochip/transports/gpr_interrupt.h>
+#include <linux/picochip/picoif_ioctl.h>
+
+#include "debug.h"
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include "picoif_module.h"
+#include "gpr_interrupt_internal.h"
+
+/*!
+ * \brief Stores the value of a GPR at interrupt time. This is dynamically
+ * allocated so that we don't need static FIFOs.
+ */
+struct gpr_int_value
+{
+    u32                 value;  /*!< The value of the GPR when the interrupt
+                                 *  was raised. */
+    struct list_head    list;   /*!< The list storing the values. */
+};
+
+/*!
+ * \brief GPR interrupt channel. Readable transport that returns the values of
+ * the GPR at each interrupt.
+ */
+struct gpr_int_channel
+{
+    int                     record_values;  /*!< Boolean flag for whether GPR
+                                             *   values should be recorded or
+                                             *   just an interrupt count. */
+    u32                     irq_count;      /*!< Number of interrupts raised. */
+    struct pico_resource    *irq;           /*!< The IRQ used for the
+                                             *   transport. */
+    struct pico_resource    *gpr;           /*!< The GPR used for the
+                                             *   transport. */
+    struct picoarray        *pa;            /*!< The picoArray running the
+                                             *   transport. */
+    struct list_head        values;         /*!< The list storing the values. */
+    spinlock_t              lock;           /*!< IRQ lock. */
+    struct picoif_context   *reader;        /*!< The reader of the channel. */
+};
+
+/*!
+ * \brief The gpr interrupt module.
+ * \extends picoif_module
+ */
+struct gpr_int_module
+{
+    struct picoif_module   mod;            /*!< The generic module. */
+    struct kmem_cache      *value_cache;   /*!< The kmem_cache for GPR values
+                                            *   when IRQs are raised. */
+};
+
+static void
+gpr_int_destructor( struct picoif_module *module );
+
+static struct picoif_context *
+gpr_int_create_trans_instance( struct picoif_module *module,
+                               const char *description,
+                               struct picoif_buf *params );
+
+static void
+gpr_int_close_trans_instance( struct picoif_module *module,
+                              struct picoif_context *ctx );
+
+static ssize_t
+gpr_int_write( struct picoif_module *module,
+               struct picoif_context *ctx,
+               struct picoif_buf *buf,
+               size_t len );
+
+static ssize_t
+gpr_int_read( struct picoif_module *module,
+              struct picoif_context *ctx,
+              struct picoif_buf *buf,
+              size_t len );
+
+static int
+gpr_int_can_write( struct picoif_module *module,
+                   struct picoif_context *ctx );
+
+static int
+gpr_int_can_read( struct picoif_module *module,
+                  struct picoif_context *ctx );
+
+/*! picoIf module operations for the GPR interrupt module. */
+static struct picoif_module_ops gpr_int_ops = {
+    .destructor             = gpr_int_destructor,
+    .create_trans_instance  = gpr_int_create_trans_instance,
+    .close_instance         = gpr_int_close_trans_instance,
+    .write                  = gpr_int_write,
+    .read                   = gpr_int_read,
+    .can_read               = gpr_int_can_read,
+    .can_write              = gpr_int_can_write,
+};
+
+/*! Transport methods for the GPR interrupt module. */
+static const char *gpr_int_tmethods[] = {
+    "with_values",
+    "without_values",
+};
+
+/*! The GPR interrupt transport module. */
+static struct gpr_int_module gpr_int_mod ={
+    .mod = {
+        .name       = "gpr_interrupt",
+        .tmethods   = gpr_int_tmethods,
+        .ops        = &gpr_int_ops,
+    },
+};
+
+/*!
+ * Write to the GPR interrupt transport. This is an invalid operation.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param buf The data to be written.
+ * @param len The length of data to be written in bytes.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+static ssize_t
+gpr_int_write( struct picoif_module *module,
+               struct picoif_context *ctx,
+               struct picoif_buf *buf,
+               size_t len )
+{
+    return -EINVAL;
+}
+
+/*!
+ * Check if the transport can be written to.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return GPR interrupt transports can not be written and will always return
+ * 0.
+ */
+static int
+gpr_int_can_write( struct picoif_module *module,
+                   struct picoif_context *ctx )
+{
+    return 0;
+}
+
+/*!
+ * Check if the transport can be read from.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return Returns 1 if the transport can be read, 0 otherwise.
+ */
+static int
+gpr_int_can_read( struct picoif_module *module,
+                  struct picoif_context *ctx )
+{
+    struct gpr_int_channel *channel = ctx->private_data;
+    return ( channel->irq_count > 0 );
+}
+
+/*!
+ * Read from the GPR interrupt transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the read.
+ * @param buf The buffer to write the data into.
+ * @param len The number of bytes requested to read.
+ * @return Returns the number of bytes read on success, negative on failure.
+ */
+static ssize_t
+gpr_int_read( struct picoif_module *module,
+              struct picoif_context *ctx,
+              struct picoif_buf *buf,
+              size_t len )
+{
+    struct gpr_int_channel *channel = ctx->private_data;
+    struct list_head *pos;
+    struct list_head *tmp;
+    const unsigned max_values =
+        channel->record_values ? len / sizeof( u32 ) : 0xFFFFFFFF;
+    unsigned i = 0;
+    struct gpr_int_value *val;
+    int ret = -EAGAIN;
+    ssize_t nbytes = 0;
+    unsigned long flags;
+    struct list_head list;
+
+    if ( len < 4 )
+        goto out;
+
+    INIT_LIST_HEAD( &list );
+
+    PRINTD( COMPONENT_GPR_INT, DBG_TRACE, "read %u bytes", len );
+
+    if ( channel->record_values )
+    {
+        spin_lock_irqsave( &channel->lock, flags );
+        list_for_each_safe( pos, tmp, &channel->values )
+        {
+            if ( max_values == i++ )
+                break;
+
+            /* Move the list entry into the copy list. */
+            list_del( pos );
+            list_add_tail( pos, &list );
+            --channel->irq_count;
+        }
+        spin_unlock_irqrestore( &channel->lock, flags );
+
+        list_for_each_safe( pos, tmp, &list )
+        {
+            val = container_of( pos, struct gpr_int_value, list );
+            ret = picoif_buf_copy_to( buf, &val->value, nbytes,
+                                      sizeof( val->value ) );
+            if ( ret )
+                goto out;
+
+            nbytes += sizeof( u32 );
+
+            kmem_cache_free( gpr_int_mod.value_cache, val );
+        }
+    }
+    else
+    {
+        u32 irq_count;
+        spin_lock_irqsave( &channel->lock, flags );
+        irq_count = channel->irq_count;
+        channel->irq_count = 0;
+        spin_unlock_irqrestore( &channel->lock, flags );
+
+        ret = picoif_buf_copy_to( buf, &irq_count, 0, sizeof( irq_count ));
+        if ( ret )
+            goto out;
+
+        if ( irq_count == 0 )
+            nbytes = -EAGAIN;
+        else
+            nbytes = sizeof( irq_count );
+    }
+
+    ret = nbytes;
+
+out:
+    return ret;
+}
+
+/*!
+ * Destructor for the gpr interrupt module.
+ *
+ * @param module The module being destroyed.
+ */
+static void
+gpr_int_destructor( struct picoif_module *module )
+{
+    kmem_cache_destroy( gpr_int_mod.value_cache );
+}
+
+/*!
+ * Handler function for interrupts raised by the GPRs in the picoArray. This
+ * is passed to the add_irq_handler method of the picoArray and is called when
+ * the interrupt is raised and must also clear the interrupt itself. This
+ * function will acknowledge the interrupt, and if we are recording values,
+ * will record the value to pass to the application when read.
+ *
+ * @param irq The irq resource that raised the interrupt.
+ * @param cookie The channel associated with the interrupt source.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+gpr_int_handler( struct pico_resource *irq,
+                 void *cookie )
+{
+    struct gpr_int_channel *channel = cookie;
+    struct picoarray *pa = channel->pa;
+    u32 val;
+
+    /* Read the register value. This clears the interrupt at the same time. */
+    int ret = pa->ops->register_read( pa, channel->gpr, &val );
+    ++channel->irq_count;
+
+    if ( channel->record_values )
+    {
+        struct gpr_int_value *gpr_val =
+            kmem_cache_alloc( gpr_int_mod.value_cache, GFP_ATOMIC );
+        ret = -ENOMEM;
+        if ( !gpr_val )
+            goto out;
+
+        gpr_val->value = val;
+        list_add_tail( &gpr_val->list, &channel->values );
+        ret = 0;
+    }
+
+out:
+    wake_up_interruptible( &channel->reader->readq );
+    return ret;
+}
+
+/*!
+ * Create a new GPR interrupt transport instance.
+ *
+ * @param module The module managing the transport.
+ * @param description The type of transport to create.
+ * @param params Extra parameters for the transport type.
+ * @return Returns the transport context on success, or an ERR_PTR on failure.
+ */
+static struct picoif_context *
+gpr_int_create_trans_instance( struct picoif_module *module,
+                               const char *description,
+                               struct picoif_buf *params )
+{
+    int ret = -ENOMEM;
+    void *private_data = NULL;
+    struct picoif_context *ctx = picoif_new_ctx( module, private_data );
+    struct picoif_gpr_int_params gparams;
+    struct picoarray *pa = NULL;
+    struct pico_resource *irq = NULL;
+    struct pico_resource *gpr = NULL;
+    struct gpr_int_channel *channel;
+    enum picoarray_device_type dev_type;
+
+    ret = picoif_buf_copy_from( &gparams, params, 0,
+                                sizeof( gparams ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    pa = picoif_get_device( gparams.dev_num );
+    if ( !pa )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "invalid device number: %u",
+                gparams.dev_num );
+        goto out;
+    }
+
+    dev_type = pa->ops->get_device_type( pa );
+    if ( !( PICOARRAY_PC3XX == dev_type ) )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN,
+                "device not supported for this transport" );
+        goto out;
+    }
+
+    ret = -EBUSY;
+    /* Request exclusive access to the IRQ resource. */
+    irq = pa->ops->get_resource( pa, PICO_RES_IRQ, gparams.irq_num, 1 );
+    if ( !irq )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "unabled to get irq: %u",
+                gparams.irq_num );
+        goto out;
+    }
+
+    /* Request exclusive access to the GPR resource. */
+    gpr = pa->ops->get_resource( pa, PICO_RES_GPR, irq->metadata, 1 );
+    if ( !gpr )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "unable to get gpr: %u",
+                irq->metadata );
+        goto out;
+    }
+
+    if ( !ctx )
+        goto out;
+
+    /* Allocate the new channel and initialise the data members. */
+    ret = -ENOMEM;
+    channel = kmalloc( sizeof( *channel ), GFP_KERNEL );
+    channel->reader = ctx;
+    ctx->private_data = channel;
+    if ( !ctx->private_data )
+        goto out;
+
+    INIT_LIST_HEAD( &channel->values );
+
+    /* Request the handler function for when the interrupt is raised. */
+    channel->irq            = irq;
+    channel->gpr            = gpr;
+    channel->pa             = pa;
+    channel->irq_count      = 0;
+    if ( !strcmp( description, "gpr_interrupt(with_values)" ) )
+        channel->record_values = 1;
+    else if ( !strcmp( description, "gpr_interrupt(without_values)" ) )
+        channel->record_values = 0;
+    else
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN, "invalid tmethod \"%s\"",
+                description );
+        ret = -EINVAL;
+        goto bad_description;
+    }
+    spin_lock_init( &channel->lock );
+
+    ret = pa->ops->add_irq_handler( pa, channel->irq, gpr_int_handler,
+                                    channel );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_GPR_INT, DBG_WARN,
+                "failed to register interrupt handler" );
+        goto handler_reg_failed;
+    }
+
+    ret = 0;
+    goto out;
+
+bad_description:
+handler_reg_failed:
+    kfree( channel );
+
+out:
+    if ( ret )
+    {
+        kfree( ctx );
+        if ( irq )
+            pa->ops->put_resource( pa, irq );
+        if ( gpr )
+            pa->ops->put_resource( pa, gpr );
+    }
+
+    return ret ? ERR_PTR( ret ) : ctx;
+}
+
+/*!
+ * Close an existing transport instance. If this instance is the last one
+ * using the channel, then destroy the channel to make sure we don't leak
+ * memory.
+ *
+ * @param mod The module handling the transport.
+ * @param ctx The context that is being closed.
+ */
+static void
+gpr_int_close_trans_instance( struct picoif_module *mod,
+                              struct picoif_context *ctx )
+{
+    struct gpr_int_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->pa;
+
+    pa->ops->remove_irq_handler( pa, channel->irq );
+    pa->ops->put_resource( pa, channel->irq );
+    pa->ops->put_resource( pa, channel->gpr );
+    kfree( ctx );
+}
+
+struct picoif_context *
+picoif_gpr_irq_ul( unsigned dev_num,
+                   int irq_num )
+{
+    struct picoif_gpr_int_params gpr_params = {
+        .dev_num    = dev_num,
+        .irq_num    = irq_num,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &gpr_params,
+        .is_user    = 0,
+    };
+    struct picoif_context *ctx =
+        gpr_int_create_trans_instance( &gpr_int_mod.mod,
+                                       "gpr_interrupt(without_values)", &buf );
+
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_gpr_irq_ul );
+
+struct picoif_context *
+picoif_gpr_irq_ul_with_values( unsigned dev_num,
+                               int irq_num )
+{
+    struct picoif_gpr_int_params gpr_params = {
+        .dev_num    = dev_num,
+        .irq_num    = irq_num,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &gpr_params,
+        .is_user    = 0,
+    };
+    struct picoif_context *ctx =
+        gpr_int_create_trans_instance( &gpr_int_mod.mod,
+                                       "gpr_interrupt(with_values)", &buf );
+
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_gpr_irq_ul_with_values );
+
+int
+gpr_interrupt_init( void )
+{
+    gpr_int_mod.value_cache =
+        kmem_cache_create( "picoif_gpr_int",
+                           sizeof( struct gpr_int_value ), 0, 0, NULL );
+    if ( !gpr_int_mod.value_cache )
+        return -ENOMEM;
+
+    return picoif_register_module( &gpr_int_mod.mod );
+}
diff --git a/drivers/picochip/gpr_interrupt_internal.h b/drivers/picochip/gpr_interrupt_internal.h
new file mode 100644
index 0000000..6d4284d
--- /dev/null
+++ b/drivers/picochip/gpr_interrupt_internal.h
@@ -0,0 +1,34 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file gpr_interrupt_internal.h
+ * \brief Initialisation function for GPR interrupt transport.
+ *
+ * Internal GPR interrupt transport functions
+ *
+ */
+
+#ifndef __PICOIF_GPR_INTERRUPT_INTERNAL_H__
+#define __PICOIF_GPR_INTERRUPT_INTERNAL_H__
+
+/*!
+ * Initialise the GPR interrupt transport.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+gpr_interrupt_init( void );
+
+#endif /* !__PICOIF_GPR_INTERRUPT_INTERNAL_H__ */
diff --git a/drivers/picochip/hwif2.c b/drivers/picochip/hwif2.c
new file mode 100644
index 0000000..68e78f4
--- /dev/null
+++ b/drivers/picochip/hwif2.c
@@ -0,0 +1,732 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file hwif2.c
+ * \brief HwIF2 transport module implementation.
+ *
+ * This file implements the HwIF2 DMA transport.
+ *
+ * One transport method is provided:
+ *   \li hwif2(ul)
+ *
+ * This transport creates one context per device which will permit a maximum of
+ * eight DMA channels to be configured assuming that the picoArray device can
+ * support this number. Each DMA channel requires a interrupt number between 0
+ * and 7 to be assigned which must match the interrupt generated in the picoArray
+ * interface code. Two GPRs are required per context for handling the handshaking
+ * between picoArray and host.
+ *
+ * There is only limited checking that can be performed for consistancy
+ * between the picoArray interface code and the application code.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+
+#include "debug.h"
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include "picoif_module.h"
+#include "hwif2_internal.h"
+#include "dma_fifo_internal.h"
+#include <linux/picochip/transports/hwif2.h>
+#include <linux/picochip/picoif_ioctl.h>
+
+/*! The maximum number of interrupts that the transport supports. */
+#define HWIF2_MAX_INTERRUPT_NUM ( 8 )
+
+/*! The maximum number of devices that the driver supports. */
+#define HWIF2_MAX_DEVICES       ( 8 )
+
+/*!
+ * \brief The context parameters used on each device
+ */
+struct hwif2_ctx_params
+{
+    unsigned interrupts_set;         /*!< The active interrupts on this device */
+    int its_gpr;                     /*!< The picoArray to host handshaking GPR */
+    int itm_gpr;                     /*!< The host to picoArray handshaking GPR */
+    struct pico_resource *its;       /*!< ITS resource */
+    struct pico_resource *itm;       /*!< ITM resource */
+    struct pico_resource *irq;       /*!< IRQ resource */
+    struct picoarray *pa;            /*!< The picoArray running the context */
+    struct dma_channel *channel[HWIF2_MAX_INTERRUPT_NUM];
+                                     /*!< DMA channels attached to this context */
+};
+
+/*!
+ * \brief The basic HwIF2 module.
+ * \extends picoif_module
+ */
+struct hwif2_module
+{
+    struct picoif_module mod;        /*!< The generic module. */
+    struct hwif2_ctx_params params[HWIF2_MAX_DEVICES];
+                                     /*!< Common parameters this transport */
+};
+
+/*!
+ * \brief DMA channel parameters (one per DMA channel).
+ */
+static struct dma_channel
+{
+    struct picoif_context *reader;    /*!< The reader of the channel. */
+    struct pico_resource *chan;       /*!< DMA channel */
+    unsigned interruptNumber;         /*!< Interrupt number for the channel */
+    unsigned maxTransferSize;         /*!< Max transfer size in bytes */
+    unsigned intCount;                /*!< Number of interrupts queued */
+    unsigned activeChannel;           /*!< Boolean to determine if the channel
+                                       *   is active */
+    unsigned xferSize;                /*!< Size of transfer in bytes */
+    unsigned totalBytes;
+    unsigned xferStartedBytes;
+    struct kfifo *fifo;               /*!< DMA FIFO */
+    spinlock_t lock;                  /*!< DMA parameter lock */
+    struct hwif2_ctx_params *hwif2Ctx;/*!< Pointer to the context parameters used
+                                       *   in this channel */
+    struct scatterlist sgl[16];        /*!< Transfer scatterlist. */
+    int nents;                        /*!< Number of scatterlist entries. */
+    struct tasklet_struct tasklet;    /*!< Tasklet for starting transfers. */
+} dma_channel;
+
+static void
+hwif2_destructor( struct picoif_module *module );
+
+static struct picoif_context *
+hwif2_create_trans_instance( struct picoif_module *module,
+                             const char *description,
+                             struct picoif_buf *params );
+
+static void
+hwif2_close_trans_instance( struct picoif_module *module,
+                            struct picoif_context *ctx );
+
+static ssize_t
+hwif2_write( struct picoif_module *module,
+             struct picoif_context *ctx,
+             struct picoif_buf *buf,
+             size_t len );
+
+static ssize_t
+hwif2_read( struct picoif_module *module,
+            struct picoif_context *ctx,
+            struct picoif_buf *buf,
+            size_t len );
+
+static int
+hwif2_can_write( struct picoif_module *module,
+                 struct picoif_context *ctx );
+
+static int
+hwif2_can_read( struct picoif_module *module,
+                struct picoif_context *ctx );
+
+static int
+hwif2_queue_transfer( struct dma_channel *channel,
+                      unsigned size );
+
+/*! picoIf module operations for the DMA module. */
+static struct picoif_module_ops hwif2_ops = {
+    .destructor             = hwif2_destructor,
+    .create_trans_instance  = hwif2_create_trans_instance,
+    .close_instance         = hwif2_close_trans_instance,
+    .write                  = hwif2_write,
+    .read                   = hwif2_read,
+    .can_read               = hwif2_can_read,
+    .can_write              = hwif2_can_write,
+};
+
+/*! Transport methods for the DMA transport module */
+static const char *hwif2_tmethods[] = {
+    "ul",
+};
+
+/*! The HwIF2 transport */
+static struct hwif2_module hwif2_mod ={
+    .mod = {
+        .name       = "hwif2",
+        .tmethods   = hwif2_tmethods,
+        .ops        = &hwif2_ops,
+    },
+};
+
+/*!
+ * Check if the transport can be written to.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return HwiF2 transports cannot be written and will always return 0
+ */
+static int
+hwif2_can_write( struct picoif_module *module,
+                 struct picoif_context *ctx )
+{
+    return 0;
+}
+
+/*!
+ * Check if the transport can be read from.
+ *
+ * @param module The module responsible for the context.
+ * @param ctx The context of the transport.
+ * @return Returns 1 if the transport can be read (and has data ready),
+ * 0 otherwise.
+ */
+static int
+hwif2_can_read( struct picoif_module *module,
+                struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    unsigned bytes_to_read = kfifo_len( channel->fifo );
+    int ret = 0;
+
+    if ( bytes_to_read )
+        return 1;
+
+    /* Start any queued transfers for this channel */
+    spin_lock_irq( &channel->lock );
+    ret = hwif2_queue_transfer( channel, 0 );
+    spin_unlock_irq( &channel->lock );
+
+    return 0;
+}
+
+/*!
+ * Handler function for interrupts generated by a completed HwIF2 transfer.
+ *
+ * @param cookie The channel associated with the interrupt source.
+ * @param errno The error number associated with the DMA transfer
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+hwif2_dma_handler( void *cookie,
+                   int errno )
+{
+    struct dma_channel *channel = cookie;
+
+    if ( errno )
+        PRINTD( COMPONENT_HWIF2, DBG_ERROR, "DMA transfer terminating "
+                "with error %d (Cookie=0x%p)", errno, cookie );
+
+    PRINTD( COMPONENT_HWIF2, DBG_TRACE,"transfer of %d bytes completed",
+            channel->xferSize );
+
+    /* Add data transferred to FIFO control parameters */
+    kfifo_dma_in_finish( channel->fifo, channel->xferSize );
+    dma_unmap_sg( NULL, channel->sgl, channel->nents, DMA_FROM_DEVICE );
+    spin_lock_irq( &channel->lock );
+    channel->activeChannel = 0;
+    wake_up_interruptible( &channel->reader->readq );
+
+    tasklet_schedule( &channel->tasklet );
+
+    spin_unlock_irq( &channel->lock );
+
+    return 0;
+}
+
+/*!
+ * Write to the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the write.
+ * @param buf The data to be written.
+ * @param len The length of data to be written in bytes.
+ * @return Returns EINVAL as a write is not permitted for this transport
+ */
+static ssize_t
+hwif2_write( struct picoif_module *module,
+             struct picoif_context *ctx,
+             struct picoif_buf *buf,
+             size_t len )
+{
+    return -EINVAL;
+}
+
+/*!
+ * Read from the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param ctx The context performing the read.
+ * @param buf The buffer to write the data into.
+ * @param len The number of bytes requested to read.
+ * @return Returns the number of bytes read on success, negative on failure.
+ */
+static ssize_t
+hwif2_read( struct picoif_module *module,
+            struct picoif_context *ctx,
+            struct picoif_buf *buf,
+            size_t len )
+{
+    struct dma_channel *channel = ctx->private_data;
+    unsigned used_bytes=0;
+    int ret = 0;
+
+    /* Determine how much data is already in the FIFO */
+    used_bytes = dma_fifo_get( channel->fifo, buf, len );
+
+    if ( !used_bytes )
+        return -EAGAIN;
+
+    PRINTD( COMPONENT_HWIF2, DBG_TRACE,
+            "read %u bytes (requested %u bytes)", used_bytes, len );
+
+    if ( ret )
+        return ret;
+    else
+        return used_bytes;
+}
+
+/*!
+ * Destructor for the DMA module.
+ *
+ * @param module The module being destroyed.
+ */
+static void
+hwif2_destructor( struct picoif_module *module )
+{
+}
+
+/*!
+ * Handler function for processing interrupts raised by the GPRs associated with
+ * this transport only. This function is passed to the add_irq_handler() method
+ * of the picoArray and is called when the specific GPR interrupt is raised.
+ * This function will acknowledge the interrupt, and start a DMA transfer
+ * of the required size.
+ *
+ * @param irq The irq resource that raised the interrupt.
+ * @param cookie The context associated with the GPR raising the interrupt.
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+hwif2_int_handler( struct pico_resource *irq,
+                   void *cookie )
+{
+    struct hwif2_ctx_params *params = cookie;
+    struct picoarray *pa = params->pa;
+    int ret = 0;
+    uint32_t its=0;
+    uint32_t itm=0;
+    unsigned size=0;
+    unsigned i=0;
+
+    /* Determine the cause of the interrupt */
+    ret = pa->ops->register_read( pa, params->its, &its );
+
+    if ( !its )
+        return 0;
+
+    /* swap ITM bits 8 & 9 and acknowledge interrupt */
+    itm = its & 0x00000300;
+    itm ^= 0x00000300;
+    ret = pa->ops->register_write( pa, params->itm, itm );
+
+    /* For HwIF2 uplink size (in words) is stored in bits 30:16 of GPR */
+    size = ((its >> 16) & 0x7fff) * 4;
+    if ( size == 0 )
+        BUG();
+
+    /* Now determine the DMA channel that caused the interrupt */
+    its = its & 0xFF; /* Bits 0:7 carry interrupt number */
+
+    /* Scan through the active DMA channels to search for the appropriate
+       channel to activate */
+    for( i=0; i < HWIF2_MAX_INTERRUPT_NUM; i++ )
+    {
+        if ((params->interrupts_set & (1 << i)) & its)
+        {
+            spin_lock( &params->channel[ i ]->lock );
+            ret = hwif2_queue_transfer( params->channel[i], size );
+            spin_unlock( &params->channel[ i ]->lock );
+            return ret;
+        }
+    }
+
+    PRINTD( COMPONENT_HWIF2, DBG_WARN,
+            "no DMA channel defined for interrupt %d", its);
+    return 0;
+}
+
+/*!
+ * Function that manages the queuing of packets for DMA transfer. This function
+ * will add the data (if provided) to the tail of a queue, and if there is no
+ * transfer in progress, extract the nexttransfer from the head of the queue.
+ *
+ * @param channel The DMA channel handle
+ * @param size The size of the transfer to add to the list
+ * @return Returns zero on success, negative on failure.
+ */
+__must_check static int
+hwif2_queue_transfer( struct dma_channel *channel,
+                      unsigned size )
+{
+
+    if ( size )
+    {
+        channel->totalBytes += size;
+        channel->intCount++;
+
+        PRINTD( COMPONENT_HWIF2, DBG_TRACE, "Transfer queued %d bytes", size );
+    }
+
+    tasklet_schedule( &channel->tasklet );
+
+    return 0;
+}
+
+static void
+hwif2_tasklet( unsigned long param )
+{
+    int size;
+    struct dma_channel *channel = ( struct dma_channel * )param;
+    struct picoarray *pa = channel->hwif2Ctx->pa;
+
+    if ( channel->activeChannel )
+        return;
+
+    spin_lock_irq( &channel->lock );
+
+    size = min( channel->totalBytes - channel->xferStartedBytes,
+                kfifo_avail( channel->fifo ) );
+    if ( size > channel->maxTransferSize )
+    {
+        PRINTD(COMPONENT_HWIF2, DBG_WARN,
+               "Transfer exceeds FIFO size or max allowed by DMA. Will truncate");
+        size = channel->maxTransferSize;
+    }
+    
+    channel->xferSize = size;
+
+    if ( size > 0 )
+    {
+        int ret;
+        channel->xferStartedBytes += size;
+
+        PRINTD( COMPONENT_HWIF2, DBG_TRACE, "start transfer of %zu bytes",
+                size );
+
+        sg_init_table( channel->sgl, 16 );
+        channel->nents = kfifo_dma_in_prepare( channel->fifo, channel->sgl, 16,
+                                               channel->xferSize );
+        channel->nents = dma_map_sg( NULL, channel->sgl, channel->nents,
+                                     DMA_FROM_DEVICE );
+
+        ret = pa->ops->dma_from_device( pa, channel->chan, channel->sgl,
+                                        channel->nents, hwif2_dma_handler,
+                                        channel );
+        if ( ret )
+        {
+            PRINTD( COMPONENT_HWIF2, DBG_ERROR,
+                    "failed to start DMA from device" );
+            BUG();
+        }
+        else
+        {
+            PRINTD( COMPONENT_HWIF2, DBG_TRACE, "started hwif2 transfer of=%u",
+                    size );
+            channel->activeChannel = 1;
+        }
+    }
+
+    spin_unlock_irq( &channel->lock );
+
+    return;
+}
+
+/*!
+ * Create a and start the DMA transport.
+ *
+ * @param module The module managing the transport.
+ * @param description The type of transport to create.
+ * @param params Extra parameters for the transport type.
+ * @return Returns the transport context on success, or an ERR_PTR on failure.
+ */
+static struct picoif_context *
+hwif2_create_trans_instance( struct picoif_module *module,
+                             const char *description,
+                             struct picoif_buf *params )
+{
+    int ret = -ENOMEM;
+    void *private_data = NULL;
+    struct picoif_context *ctx = picoif_new_ctx( module, private_data );
+    struct picoif_hwif2_params gparams;
+    struct picoarray *pa = NULL;
+    struct dma_channel *channel;
+    struct pico_resource *chan = NULL;
+    enum picoarray_device_type dev_type;
+    struct pico_resource *its_irq = NULL;
+
+    ret = picoif_buf_copy_from( &gparams, params, 0,
+                                sizeof( gparams ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    pa = picoif_get_device( gparams.dev_num );
+    if ( !pa )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_WARN, "invalid device number: %u",
+                gparams.dev_num );
+        goto out;
+    }
+
+    dev_type = pa->ops->get_device_type( pa );
+    if ( !( PICOARRAY_PC3XX == dev_type ) )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_WARN,
+                "device not supported for this transport" );
+        goto out;
+    }
+
+    /* Check that the DMA channel is not already in use */
+    ret = -EBUSY;
+    chan = pa->ops->get_resource( pa, PICO_RES_DMA_CHANNEL,
+                                             gparams.channel, 1 );
+    if ( !chan )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_ERROR, "invalid DMA channel:%u",
+                gparams.channel );
+        goto out;
+    }
+
+    /* Check that the interrupt number is valid */
+    if (gparams.dev_num >= HWIF2_MAX_INTERRUPT_NUM)
+        goto out;
+
+    /* If this is the first transport on the device, set the context
+       parameters */
+    if ( !hwif2_mod.params[gparams.dev_num].interrupts_set )
+    {
+        struct pico_resource *its_gpr;
+        struct pico_resource *itm_gpr;
+
+        ret = -EBUSY;
+        itm_gpr = pa->ops->get_resource( pa, PICO_RES_GPR, gparams.itm_gpr, 1 );
+        if ( !itm_gpr )
+        {
+            PRINTD( COMPONENT_HWIF2, DBG_WARN, "unable to get itm gpr: %u",
+                    gparams.itm_gpr );
+            goto out;
+        }
+
+        its_gpr = pa->ops->get_resource( pa, PICO_RES_GPR, gparams.its_gpr, 1 );
+        if ( !its_gpr )
+        {
+            PRINTD( COMPONENT_HWIF2, DBG_WARN, "unable to get its gpr: %u",
+                    gparams.its_gpr );
+            pa->ops->put_resource( pa, itm_gpr );
+            goto out;
+        }
+
+        its_irq = pa->ops->get_resource( pa, PICO_RES_IRQ, its_gpr->metadata,
+                                         1 );
+        if ( !its_irq )
+        {
+            PRINTD( COMPONENT_HWIF2, DBG_WARN, "unable to get irq: %u",
+                    gparams.its_gpr );
+            pa->ops->put_resource( pa, its_gpr );
+            pa->ops->put_resource( pa, itm_gpr );
+            goto out;
+        }
+
+        hwif2_mod.params[gparams.dev_num].interrupts_set |= (1 << gparams.int_num);
+        hwif2_mod.params[gparams.dev_num].its_gpr = gparams.its_gpr;
+        hwif2_mod.params[gparams.dev_num].itm_gpr = gparams.itm_gpr;
+        hwif2_mod.params[gparams.dev_num].its = its_gpr;
+        hwif2_mod.params[gparams.dev_num].itm = itm_gpr;
+        hwif2_mod.params[gparams.dev_num].irq = its_irq;
+        hwif2_mod.params[gparams.dev_num].pa = pa;
+    }
+    else
+    { /* Check that the common parameters are consistant */
+        if (( gparams.its_gpr != hwif2_mod.params[gparams.dev_num].its_gpr ) ||
+            ( gparams.itm_gpr != hwif2_mod.params[gparams.dev_num].itm_gpr ) ||
+            ( hwif2_mod.params[gparams.dev_num].interrupts_set &
+                                                        (1 << gparams.int_num) ))
+            goto out;
+
+        hwif2_mod.params[gparams.dev_num].interrupts_set |= (1 << gparams.int_num);
+    }
+
+    if ( !ctx )
+        goto out;
+
+    /* Allocate the new channel and initialise the data members. */
+    ret = -ENOMEM;
+    channel = kzalloc( sizeof( dma_channel ), GFP_KERNEL );
+    if (!channel)
+        goto out;
+    ctx->private_data = channel;
+
+    channel->fifo = dma_buf_cache_alloc( gparams.buf_size );
+    if ( !channel->fifo )
+        goto bad_fifo_alloc;
+
+    channel->reader = ctx;
+    channel->hwif2Ctx = &hwif2_mod.params[gparams.dev_num];
+    channel->interruptNumber = gparams.int_num;
+    if ( gparams.buf_size > pa->max_dma_sz )
+        channel->maxTransferSize = pa->max_dma_sz;
+    else
+        channel->maxTransferSize = gparams.buf_size;
+    channel->chan = chan;
+    channel->intCount = 0;
+    channel->xferSize = 0;
+    channel->activeChannel = 0;
+    channel->xferStartedBytes = 0;
+    hwif2_mod.params[gparams.dev_num].channel[gparams.int_num] = channel;
+
+    spin_lock_init( &channel->lock );
+
+    if ( strcmp( description, "hwif2(ul)" ) )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_ERROR, "invalid tmethod \"%s\"",
+                description );
+        ret = -EINVAL;
+        goto bad_description;
+    }
+
+    ret = pa->ops->dma_open( pa, chan );
+    if ( ret )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_ERROR, "failed to open DMA channel" );
+        goto bad_description;
+    }
+
+    tasklet_init( &channel->tasklet, hwif2_tasklet, ( unsigned long )channel );
+
+    if ( its_irq )
+    {
+        ret = pa->ops->add_irq_handler( pa, its_irq, hwif2_int_handler,
+                                        channel->hwif2Ctx );
+        if ( ret )
+        {
+            PRINTD( COMPONENT_HWIF2, DBG_ERROR,
+                    "failed to register interrupt handler" );
+            goto handler_reg_failed;
+        }
+    }
+
+    ret = 0;
+    goto out;
+
+bad_description:
+handler_reg_failed:
+   dma_buf_cache_free( channel->fifo );
+
+bad_fifo_alloc:
+    kfree( channel );
+
+out:
+    if ( ret )
+    {
+        kfree( ctx );
+        if ( chan )
+            pa->ops->put_resource(  pa, chan );
+    }
+
+    return ret ? ERR_PTR( ret ) : ctx;
+}
+
+/*!
+ * Close an existing transport instance.
+ *
+ * @param mod The module handling the transport.
+ * @param ctx The context that is being closed.
+ */
+static void
+hwif2_close_trans_instance( struct picoif_module *mod,
+                            struct picoif_context *ctx )
+{
+    struct dma_channel *channel = ctx->private_data;
+    struct picoarray *pa = channel->hwif2Ctx->pa;
+    unsigned interrupt_bit = ((uint32_t)1) << channel->interruptNumber;
+    struct hwif2_ctx_params *params = channel->hwif2Ctx;
+
+    tasklet_disable( &channel->tasklet );
+    tasklet_kill( &channel->tasklet );
+    (void)pa->ops->dma_close( pa, channel->chan );
+
+    PRINTD( COMPONENT_HWIF2, DBG_TRACE, "close transport instance" );
+
+    pa->ops->put_resource( pa, channel->chan );
+    dma_buf_cache_free( channel->fifo );
+
+    params->interrupts_set &= ( ~interrupt_bit );
+    params->channel[channel->interruptNumber] = NULL;
+
+    if ( !params->interrupts_set )
+    {
+        PRINTD( COMPONENT_HWIF2, DBG_TRACE,
+                "no further hwif2 users for device %u", pa->dev_num );
+        pa->ops->remove_irq_handler( pa, params->irq );
+        pa->ops->put_resource( pa, params->its );
+        pa->ops->put_resource( pa, params->itm );
+        pa->ops->put_resource( pa, params->irq );
+    }
+
+    if ( channel )
+        kfree( channel );
+
+    if ( ctx )
+        kfree( ctx );
+
+    PRINTD( COMPONENT_HWIF2, DBG_TRACE, "transport instance closed" );
+}
+
+/* Kernel API and Public functions */
+struct picoif_context *
+picoif_hwif2_dmaul_open( const picoif_hwif2_t hwif2_context,
+                         unsigned interrupt_number,
+                         int dma_channel,
+                         size_t buffer_size )
+{
+    struct picoif_hwif2_params hwif2_params = {
+        .dev_num    = hwif2_context->dev_num,
+        .int_num    = interrupt_number,
+        .channel    = dma_channel,
+        .buf_size   = buffer_size,
+        .its_gpr    = hwif2_context->its_gpr,
+        .itm_gpr    = hwif2_context->itm_gpr,
+    };
+    struct picoif_buf buf = {
+        .kbuf       = &hwif2_params,
+        .is_user    = 0,
+    };
+    struct picoif_context *ctx =
+        hwif2_create_trans_instance( &hwif2_mod.mod,
+                                       "hwif2(ul)", &buf );
+    return ctx;
+}
+EXPORT_SYMBOL( picoif_hwif2_dmaul_open );
+
+int
+hwif2_init( void )
+{
+    memset(hwif2_mod.params, sizeof ( hwif2_mod.params ), 0 );
+
+    return picoif_register_module( &hwif2_mod.mod );
+}
+
+
diff --git a/drivers/picochip/hwif2_internal.h b/drivers/picochip/hwif2_internal.h
new file mode 100644
index 0000000..b48ed7b
--- /dev/null
+++ b/drivers/picochip/hwif2_internal.h
@@ -0,0 +1,33 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file hwif2_internal.h
+ * \brief Initialisation function for HwIF2 transport.
+ *
+ * Internal HwIF2 transport function definitions
+ */
+
+#ifndef __PICOIF_HWIF2_INTERNAL_H__
+#define __PICOIF_HWIF2_INTERNAL_H__
+
+/*!
+ * Initialise the HwIF2 transport.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+hwif2_init( void );
+
+#endif /* !__PICOIF_HWIF2_INTERNAL_H__ */
diff --git a/drivers/picochip/pc3xx.c b/drivers/picochip/pc3xx.c
new file mode 100644
index 0000000..f7a600a
--- /dev/null
+++ b/drivers/picochip/pc3xx.c
@@ -0,0 +1,1446 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file pc3xx.c
+ * \brief PC3XX device implementation.
+ *
+ * This file implements the PC3XX support of picoIf. All implementation in
+ * this file is private and should not be accessed directly by users and only
+ * provides the necessary basic services with which transports can be built
+ * upon and devices configured.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/dw_dmac.h>
+#include <linux/jiffies.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <mach/picoxcell/axi2cfg.h>
+#include <mach/picoxcell/picoxcell.h>
+
+#include <linux/picochip/picoif.h>
+#include <linux/picochip/devices/pc3xx.h>
+
+#include "picoarray.h"
+#include "resource.h"
+#include "picoif_internal.h"
+#include "debug.h"
+#include "utilities_internal.h"
+
+/*! The address of the AXI2Pico interrupt status register. This is an offset
+ * from the AXI2Pico base address. */
+#define AXI2PICO_INT_STATUS_OFFSET  ( 0x0200 )
+
+/*! The number of virtual ports in the AXI2Pico. */
+#define AXI2PICO_NUM_VPS           ( 32 )
+
+/*! The spacing of virtual ports in the AXI2Pico. */
+#define AXI2PICO_VP_SPACING         ( 0x10 )
+
+/*! The offset of a virtual port config register from the virtual port
+ *  register base. */
+#define AXI2PICO_VP_CONFIG_OFFSET   ( 0x00 )
+
+/*! The offset of a virtual port status register from the virtual port
+ *  register base. */
+#define AXI2PICO_VP_STATUS_OFFSET   ( 0x04 )
+
+/*! The offset of the data register for a virtual port in the AXI2Pico. */
+#define AXI2PICO_VP_DATA_OFFSET     ( 0x08 )
+
+/*! The CAEID of the procif. */
+#define PC3XX_AXI2CFG_CAEID          ( 0x48 )
+
+/*! The CAEID of the AXI2Pico. */
+#define PC3XX_AXI2PICO_CAEID	     ( 0x9000 )
+
+/*! The CAEID of the Frac-N. */
+#define PC3XX_FRACN_CAEID            ( 0x8080 )
+
+/*! The offset in the procif for the multi step count registers (4). */
+#define PC3XX_PROCIF_MULTI_CNT_OFFSET ( 0x4004 )
+
+/*! The offset in the procif for the operation request register. */
+#define PC3XX_AXI2CFG_OP_REQ_OFFSET  ( 0x4018 )
+
+/*! The offset of the sync bit in the operation request register */
+#define PC3XX_AXI2CFG_OP_REQ_SYNC      ( 1 << 0 )
+
+/*! The offset of the start request bit in the operation request register. */
+#define PC3XX_AXI2CFG_OP_REQ_START   ( 1 << 1 )
+
+/*! The offset of the step request bit in the operation request register. */
+#define PC3XX_AXI2CFG_OP_REQ_STEP    ( 1 << 2 )
+
+/*! The offset in the procif for the operation status register. */
+#define PC3XX_AXI2CFG_OP_STATUS_OFFSET  ( 0x401c )
+
+/*! The offset of the step  bit in the operation status register */
+#define PC3XX_AXI2CFG_OP_STATUS_STEPPING ( 1 << 0 )
+
+/*! The offset of the start bit in the operation status register */
+#define PC3XX_AXI2CFG_OP_STATUS_RUNNING  ( 1 << 1 )
+
+/*! The offset of the sync bit in the operation status register */
+#define PC3XX_AXI2CFG_OP_STATUS_IN_SYNC  ( 0 << 2 )
+
+/*! The number of multi count registers */
+#define PC3XX_NUM_MULTI_COUNT_REGS    ( 4 )
+
+/*! The position of the interrupt enable bit in a virtual port config
+ *  register. */
+#define AXI2PICO_INT_EN             ( 1 << 0 )
+
+/*! The offset in an AE for the sleep register. */
+#define SLEEP_REG_OFFSET	    ( 0xA060 )
+
+/*! Timeout for DMA load of picoArray */
+#define TIMEOUT_10MS                ( HZ / 100 )
+
+/*! DMA burst size in words */
+#define PC3XX_DMA_BURST_SIZE        ( 1 )
+
+/*! The maximum number of transactions per transfer */
+#define DMAH_CHX_MAX_BLK_SIZE       ( 4095 )
+
+/*! Determine the msize and max transfer size that is permitted */
+#if ((PC3XX_DMA_BURST_SIZE == 1) || (PC3XX_DMA_BURST_SIZE == 2))
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC3XX_DMA_MS_1_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 4)
+#elif (PC3XX_DMA_BURST_SIZE == 4)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC3XX_DMA_MS_4_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 8)
+#elif (PC3XX_DMA_BURST_SIZE == 8)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC3XX_DMA_MS_8_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 16)
+#elif (PC3XX_DMA_BURST_SIZE == 16)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC3XX_DMA_MS_16_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 32)
+#elif (PC3XX_DMA_BURST_SIZE == 32)
+    #define SET_PICOARRAY_MSIZE(__e) ( __e.msize = PC3XX_DMA_MS_32_TRW)
+    #define PICOARRAY_MAX_TRANSFER ((DMAH_CHX_MAX_BLK_SIZE/4) * 64)
+#else
+    #error
+#endif
+
+/*!
+ * Determine if a GPR port is enabled
+ */
+#define IS_PORT_ENABLED(status_reg) (status_reg & 0x1)
+
+/*!
+ *  Determine if a GPR port is configured as a receive port
+ */
+#define IS_PORT_A_RECEIVE(status_reg) (status_reg & 0x2)
+
+/*!
+ *  Determine if a GPR port is configured as a non blocking port
+ */
+#define IS_PORT_NONBLOCKING(status_reg) (status_reg & 0x4)
+
+/*!
+ *  Determine if a GPR port is ready to give or receive data
+ */
+#define IS_PORT_READY_FOR_DATA(status_reg) (status_reg & 0x8)
+
+/*! The number of registered PC3XXs in the system. Until this reaches zero, we
+ * can't unregister the platform driver. */
+static unsigned num_pc3xxs;
+
+static void
+pc3xx_destroy( struct picoarray *pa );
+
+/*!
+ * \brief PC3XX IRQ handler.
+ *
+ * This structure defines an IRQ handler for PC3XX devices and is an internal
+ * structure that could be reused for other device types.
+ */
+struct pc3xx_irq_handler
+{
+    /*! The position in the list of handlers for an interrupt source. */
+    struct list_head        list;
+
+    /*! The IRQ that this handles. */
+    struct pico_resource    *irq;
+
+    /*! A cookie to pass to the callback function when the interrupt is
+     * raised. */
+    void                    *cookie;
+
+    /*! The callback function to call when the interrupt is raised. */
+    int                     ( *callback )( struct pico_resource *irq,
+                                           void *cookie );
+};
+
+/*!
+ * \brief PC3XX DMA handler
+ *
+ * This structure defines a DMA handler for PC3XX devices and is an internal
+ * strucutre that might be reused for other device types that uses the Synopsys
+ * DMAC. There will be one instance of this structure per DMA channel in the
+ * system.
+ */
+struct pc3xx_dma_channel
+{
+    struct dw_dma_slave slave;
+
+    struct dma_chan *chan;
+
+    /*! picoArray DMA channel number */
+    unsigned channel;
+
+    /*! Channel status (1 for active and 0 for waiting) */
+    int stateActive;
+
+    /*! Physical address for the picoArray DMA channel */
+    dma_addr_t pico_addr;
+
+    /*! The callback function to call when the DMA transfer is completed. */
+    int ( *callback )( void *cookie,
+                       int errno );
+
+    /*! User data */
+    void *cookie;
+
+    struct dma_async_tx_descriptor *curr_desc;
+};
+
+/*!
+ * \brief Private representation of a PC3XX device.
+ *
+ * This describes all private data required in the PC3XX implementation of
+ * this driver.
+ *
+ * \extends picoarray
+ */
+struct pc3xx
+{
+    /*! The picoArray base class. */
+    struct picoarray            pa;
+
+    /*! The physical address of the lower axi2cfg registers. */
+    dma_addr_t                  axi2cfg1_base_phys;
+
+    /*! The length of the lowe axi2cfg registers in bytes. */
+    size_t                      axi2cfg1_base_len;
+
+    /*! The virtually mapped address of the lower axi2cfg registers. */
+    void __iomem                *axi2cfg1_base;
+
+    /*! The physical address of the upper axi2cfg registers. */
+    dma_addr_t                  axi2cfg2_base_phys;
+
+    /*! The length of the upper axi2cfg registers in bytes. */
+    size_t                      axi2cfg2_base_len;
+
+    /*! The physical address of the AXI2Pico registers. */
+    dma_addr_t                  axi2pico_base_phys;
+
+    /*! The length of the AXI2Pico registers in bytes. */
+    size_t                      axi2pico_base_len;
+
+    /*! The virtually mappped address of the AXI2Pico registers. */
+    void __iomem                *axi2pico_base;
+
+    /*! The AXI2Pico IRQ number. The AXI2Pico supports a number of interrupt
+     * sources, but these are all raised through a single IRQ line. */
+    unsigned                    gpr_irq;
+
+    /*! The handlers registered for the AXI2Pico IRQ. */
+    struct pc3xx_irq_handler    axi2pico_irq_handlers;
+
+    /*! DMA channel data */
+    struct pc3xx_dma_channel    dma_channel[PICO_NUM_DMA_CHANNELS];
+
+    struct device               *axi2pico_dmac;
+    struct device               *axi2cfg_dmac;
+};
+
+/*!
+ * Get the PC3XX structure given a picoArray base class.
+ *
+ * @param pa The base class pointer.
+ * @return Returns a pointer to the PC3XX structure on success, NULL on
+ * failure.
+ */
+static inline struct pc3xx *
+to_pc3xx( struct picoarray *pa )
+{
+    return pa ? container_of( pa, struct pc3xx, pa ) : NULL;
+}
+
+/*!
+ * Write the value of an AXI2Pico register.
+ *
+ * @param dev The PC3XX owning the AXI2Pico.
+ * @param offset The offset of the register in bytes.
+ * @param value The value of the register to write.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_axi2pico_reg_write( struct pc3xx *dev,
+                          unsigned offset,
+                          u32 value )
+{
+    PRINTD( COMPONENT_PC3XX, DBG_TRACE, "pA[%u] axi2pico, %04x:=%08x",
+            dev->pa.dev_num, offset, value );
+    picoif_out32( value, dev->axi2pico_base + offset );
+    return 0;
+}
+
+/*!
+ * Read the value of an AXI2Pico register.
+ *
+ * @param dev The PC3XX owning the AXI2Pico.
+ * @param offset The offset of the register in bytes.
+ * @param[out] value Pointer to the address to store the register value in.
+ */
+static void
+pc3xx_axi2pico_reg_read( struct pc3xx *dev,
+                         unsigned offset,
+                         u32 *value )
+{
+    *value = picoif_in32( dev->axi2pico_base + offset );
+}
+
+/*!
+ * Read a number of 16 bit words from the PC3XX axi2cfg.
+ *
+ * @param pa The device to read from.
+ * @param caeid The CAEID of the AE to read from.
+ * @param address The start address in the AE to begin reading from.
+ * @param count The number of 16 bit words to read.
+ * @param[out] data The buffer to store the data in.
+ * @return Returns the number of words read on success, negative on failure.
+ */
+static int
+pc3xx_config_read( struct picoarray *pa,
+                   u16 caeid,
+                   u16 address,
+                   u16 count,
+                   u16 *data )
+{
+    PRINTD( COMPONENT_PC3XX, DBG_TRACE,
+            "pa[%u]: config read %u words %04x@%04x", pa->dev_num,
+            count, caeid, address );
+
+    return axi2cfg_config_read( caeid, address, data, count );
+}
+
+/*!
+ * Write a number of 16 bit words to the PC3XX axi2cfg.
+ *
+ * @param pa The device to write to.
+ * @param caeid The CAEID of the AE to write to.
+ * @param address The start address in the AE to begin writing to.
+ * @param count The number of 16 bit words to write.
+ * @param[in] data The buffer to write from.
+ * @return Returns the number of words written on success, negative on failure.
+ */
+static int
+pc3xx_config_write( struct picoarray *pa,
+                    u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *data )
+{
+    PRINTD( COMPONENT_PC3XX, DBG_TRACE,
+            "pa[%u]: config write %u words %04x@%04x", pa->dev_num,
+            count, caeid, address );
+
+    axi2cfg_config_write( caeid, address, data, count );
+
+    return count;
+}
+
+/*!
+ * Sync the PC3XX device. PC3XX requires no synchronisation as it is a single
+ * device so do nothing.
+ *
+ * @param pa The device to sync.
+ * @return Always returns zero.
+ */
+static int
+pc3xx_sync( struct picoarray *pa )
+{
+    return 0;
+}
+
+static int
+pc3xx_is_running( struct picoarray *pa )
+{
+    u16 val;
+
+    if ( 1 != pa->ops->config_read( pa, PC3XX_AXI2CFG_CAEID,
+                                    PC3XX_AXI2CFG_OP_STATUS_OFFSET, 1, &val ) )
+        return 0;
+
+    return val & ( PC3XX_AXI2CFG_OP_STATUS_RUNNING |
+                   PC3XX_AXI2CFG_OP_STATUS_STEPPING );
+}
+
+/*!
+ * Start the PC3XX device running.
+ *
+ * @param pa The device to start.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_start( struct picoarray *pa )
+{
+    u16 val;
+    u16 cycle_count[PC3XX_NUM_MULTI_COUNT_REGS];
+    int ret = 0;
+    
+    /* Only perform a start on the master device (assumed 0 ) */
+    if ( pa->dev_num == 0 )
+    {
+        if ( pc3xx_is_running( pa ) )
+        {
+            PRINTD( COMPONENT_PC3XX, DBG_WARN, "system already running");
+            goto out;
+        }
+
+        /* Read multi cycle count register to determine if we are to perform
+           a run forever or a step for a number of cycles */
+        ret = pa->ops->config_read( pa, PC3XX_AXI2CFG_CAEID,
+            PC3XX_PROCIF_MULTI_CNT_OFFSET, PC3XX_NUM_MULTI_COUNT_REGS, cycle_count );
+        if ( ret != PC3XX_NUM_MULTI_COUNT_REGS )
+        {
+            ret = -EINVAL;
+            PRINTD( COMPONENT_PC3XX, DBG_ERROR,
+                "failed to read multi count reg" );
+            goto out;
+        }
+
+        /* Only run if the 50 bit count register is zero */
+        if ( ( cycle_count[0] | cycle_count[1] | cycle_count[2] |
+              (cycle_count[3] & 0x3) ) == 0 )
+        {
+            val = PC3XX_AXI2CFG_OP_REQ_START;
+        }
+        else
+        {
+        val = PC3XX_AXI2CFG_OP_REQ_STEP;
+        }
+    
+        ret = pa->ops->config_write( pa, PC3XX_AXI2CFG_CAEID,
+                                 PC3XX_AXI2CFG_OP_REQ_OFFSET, 1, &val );
+        if ( 1 != ret )
+            goto out;
+    }
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Stop the PC3XX device running.
+ *
+ * @param pa The device to stop.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_stop( struct picoarray *pa )
+{
+    u16 val;
+    int ret = 0;
+
+    /* Only perform a start on the master device (assumed 0 ) */
+    if ( pa->dev_num == 0 )
+    {
+        if ( !pc3xx_is_running( pa ) )
+        {
+            PRINTD( COMPONENT_PC3XX, DBG_WARN, "system is not running" );
+            goto out;
+        }
+
+        val = 0;
+        ret = pa->ops->config_write( pa, PC3XX_AXI2CFG_CAEID,
+            PC3XX_AXI2CFG_OP_REQ_OFFSET, 1, &val );
+        if ( 1 != ret )
+            goto out;
+    }
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*! The CAEID of the MemIf. */
+#define PC3XX_MEMIF_CAEID           ( 0x8020 )
+/*! The address of the FIFO status lower register. */
+#define PC3XX_MEMIF_FIFO_STAT_LOW   ( 0x0080 )
+
+/*! The CAEID of the PAI */
+#define PC3XX_PAI_CAEID             ( 0x8080 )
+/*! The address of the pai_io_ctrl register. */
+#define PC3XX_PAI_IO_CTRL_REG       ( 0x0009 )
+
+/*!
+ * Reset the PC3XX. This performs a soft reset that returns the picoArray to
+ * be as close as possible to the hardware reset state without affecting the
+ * ARM subsystem.
+ *
+ * @param pa The device being reset.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_reset( struct picoarray *pa )
+{
+    int ret;
+    unsigned long flags;
+    u16 val;
+    u16 io_ctrl_value;
+
+    u16 buf_vals[ 0x14 ] = {
+                            0xf0, 0, 0xf0, 0, 0xf0, 0, 0xf0, 0, 0xf0, 0,
+                            0xf0, 0, 0xf0, 0, 0xf0, 0, 0xf0, 0, 0xf0, 0,
+                           };
+    u16 error_vals[ 4 ] = { 0, 0, 0, 0, };
+
+    PRINTD( COMPONENT_PC3XX, DBG_TRACE, "pa[%u]: reset", pa->dev_num );
+
+    spin_lock_irqsave( &pa->lock, flags );
+    ret = pa->ops->config_write( pa, PC3XX_MEMIF_CAEID, 0, 0x14, buf_vals );
+    if ( 0x14 != ret )
+        goto out;
+
+    ret = pa->ops->config_write( pa, PC3XX_MEMIF_CAEID,
+                                 PC3XX_MEMIF_FIFO_STAT_LOW, 4, error_vals );
+    if ( 4 != ret )
+        goto out;
+
+    /* Save the PAI io_ctrl register value */
+    ret = pa->ops->config_read( pa, PC3XX_PAI_CAEID,
+                                PC3XX_PAI_IO_CTRL_REG, 1,
+                                &io_ctrl_value );
+    if ( 1 != ret )
+        goto out;
+
+    axi2cfg_writel( axi2cfg_readl( AXI2CFG_SYSCFG_REG_OFFSET ) |
+		    AXI2CFG_SYSCFG_PA_RST_MASK,
+		    AXI2CFG_SYSCFG_REG_OFFSET );
+
+    /* Wait for the reset to clear. */
+    while ( axi2cfg_readl( AXI2CFG_SYSCFG_REG_OFFSET ) &
+	    AXI2CFG_SYSCFG_PA_RST_MASK )
+        cpu_relax();
+
+    /* Wake the AXI2Pico and the Frac-N back up. We need to do this so that the
+     * GPIO driver and Frac-N drivers can keep running without losing access to
+     * their blocks. */
+    val = 0;
+    ret =  pa->ops->config_write( pa, PC3XX_AXI2PICO_CAEID,
+				  SLEEP_REG_OFFSET, 1, &val );
+    if ( 1 != ret)
+        goto out;
+
+    ret = pa->ops->config_write( pa, PC3XX_FRACN_CAEID,
+				 SLEEP_REG_OFFSET, 1, &val );
+    if ( 1 != ret)
+        goto out;
+
+    /* Wake up the PAI up so we can restore the io_ctrl register
+     * back to what it was prior to the reset happening. */
+    ret = pa->ops->config_write( pa, PC3XX_PAI_CAEID,
+                                 SLEEP_REG_OFFSET, 1, &val );
+    if ( 1 != ret)
+        goto out;
+
+    /* Restore the PAI io_ctrl register value */
+    ret = pa->ops->config_write( pa, PC3XX_PAI_CAEID,
+                                 PC3XX_PAI_IO_CTRL_REG, 1,
+                                 &io_ctrl_value );
+    if ( 1 != ret)
+        goto out;
+
+    ret = 0;
+
+out:
+    spin_unlock_irqrestore( &pa->lock, flags );
+    return ret;
+}
+
+/*!
+ * Read a GPR (general purpose register) in the PC3XX.
+ *
+ * @param pa The device being read from.
+ * @param reg The register to read.
+ * @param[out] value The address to store the register value in.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_register_read( struct picoarray *pa,
+                     struct pico_resource *reg,
+                     u32 *value )
+{
+    struct pc3xx *dev = to_pc3xx( pa );
+    u32 gprStatus = 0;
+
+    if ( !reg || PICO_RES_GPR != reg->type )
+        return -EINVAL;
+
+    if ( reg->value < PC3XX_GPR_AXI2PICO_0 ||
+         reg->value > PC3XX_GPR_AXI2PICO_23 )
+        return -EINVAL;
+
+    if ( !pc3xx_is_running( pa ) )
+        return -EPERM;
+
+    pc3xx_axi2pico_reg_read( dev, reg->offset + AXI2PICO_VP_STATUS_OFFSET,
+                             &gprStatus );
+    if ((!IS_PORT_ENABLED(gprStatus)) ||
+        (!IS_PORT_A_RECEIVE(gprStatus)) ||
+        (!IS_PORT_READY_FOR_DATA(gprStatus)))
+      return -EINVAL;
+
+    pc3xx_axi2pico_reg_read( dev, reg->offset + AXI2PICO_VP_DATA_OFFSET,
+                             value );
+
+    return 0;
+}
+
+/*!
+ * Write a GPR (general purpose register) in the PC3XX.
+ *
+ * @param pa The device being written to.
+ * @param reg The register to write.
+ * @param value The value to write to the register.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_register_write( struct picoarray *pa,
+                      struct pico_resource *reg,
+                      u32 value )
+{
+    struct pc3xx *dev = to_pc3xx( pa );
+    u32 gprStatus = 0;
+
+    if ( !reg || PICO_RES_GPR != reg->type )
+        return -EINVAL;
+
+    if ( reg->value < PC3XX_GPR_AXI2PICO_0 ||
+         reg->value > PC3XX_GPR_AXI2PICO_23 )
+        return -EINVAL;
+
+    if ( !pc3xx_is_running( pa ) )
+        return -EPERM;
+
+    pc3xx_axi2pico_reg_read( dev, reg->offset + AXI2PICO_VP_STATUS_OFFSET,
+          &gprStatus );
+    if ((!IS_PORT_ENABLED(gprStatus)) ||
+        (IS_PORT_A_RECEIVE(gprStatus)) ||
+        (!IS_PORT_READY_FOR_DATA(gprStatus)))
+      return -EINVAL;
+
+    pc3xx_axi2pico_reg_write( dev, reg->offset + AXI2PICO_VP_DATA_OFFSET,
+                              value );
+
+    return 0;
+}
+
+/*!
+ * Load the picoArray specified with the array of data
+ *
+ * @param pa The device being written to.
+ * @param data The virtual address of the buffer to write
+ * @param sgl The scatter gather list of the source data.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_pa_load( struct picoarray *pa,
+               u32 *data,
+               struct scatterlist *sgl  )
+{
+    struct scatterlist *pos;
+
+    for ( pos = sgl; pos; pos = sg_next( pos ) )
+    {
+        unsigned nr_words = pos->length / sizeof( u32 );
+
+        axi2cfg_write_buf( sg_virt( pos ), nr_words );
+    }
+
+    return 0;
+}
+
+/*! The resources for a PC3XX device. */
+static struct pico_resource pc3xx_resources[] = {
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC3XX_DMA_AXI2PICO_0, .offset = 0x00 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC3XX_DMA_AXI2PICO_1, .offset = 0x10 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC3XX_DMA_AXI2PICO_2, .offset = 0x20 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC3XX_DMA_AXI2PICO_3, .offset = 0x30 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC3XX_DMA_AXI2PICO_4, .offset = 0x40 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC3XX_DMA_AXI2PICO_5, .offset = 0x50 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC3XX_DMA_AXI2PICO_6, .offset = 0x60 },
+    { .type = PICO_RES_DMA_CHANNEL, .value = PC3XX_DMA_AXI2PICO_7, .offset = 0x70 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_0, .metadata = PC3XX_IRQ_AXI2PICO_0, .offset = 0x80 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_1, .metadata = PC3XX_IRQ_AXI2PICO_1, .offset = 0x90 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_2, .metadata = PC3XX_IRQ_AXI2PICO_2, .offset = 0xa0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_3, .metadata = PC3XX_IRQ_AXI2PICO_3, .offset = 0xb0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_4, .metadata = PC3XX_IRQ_AXI2PICO_4, .offset = 0xc0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_5, .metadata = PC3XX_IRQ_AXI2PICO_5, .offset = 0xd0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_6, .metadata = PC3XX_IRQ_AXI2PICO_6, .offset = 0xe0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_7, .metadata = PC3XX_IRQ_AXI2PICO_7, .offset = 0xf0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_8, .metadata = PC3XX_IRQ_AXI2PICO_8, .offset = 0x100 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_9, .metadata = PC3XX_IRQ_AXI2PICO_9, .offset = 0x110 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_10, .metadata = PC3XX_IRQ_AXI2PICO_10, .offset = 0x120 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_11, .metadata = PC3XX_IRQ_AXI2PICO_11, .offset = 0x130 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_12, .metadata = PC3XX_IRQ_AXI2PICO_12, .offset = 0x140 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_13, .metadata = PC3XX_IRQ_AXI2PICO_13, .offset = 0x150 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_14, .metadata = PC3XX_IRQ_AXI2PICO_14, .offset = 0x160 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_15, .metadata = PC3XX_IRQ_AXI2PICO_15, .offset = 0x170 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_16, .metadata = PC3XX_IRQ_AXI2PICO_16, .offset = 0x180 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_17, .metadata = PC3XX_IRQ_AXI2PICO_17, .offset = 0x190 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_18, .metadata = PC3XX_IRQ_AXI2PICO_18, .offset = 0x1a0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_19, .metadata = PC3XX_IRQ_AXI2PICO_19, .offset = 0x1b0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_20, .metadata = PC3XX_IRQ_AXI2PICO_20, .offset = 0x1c0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_21, .metadata = PC3XX_IRQ_AXI2PICO_21, .offset = 0x1d0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_22, .metadata = PC3XX_IRQ_AXI2PICO_22, .offset = 0x1e0 },
+    { .type = PICO_RES_GPR, .value = PC3XX_GPR_AXI2PICO_23, .metadata = PC3XX_IRQ_AXI2PICO_23, .offset = 0x1f0 },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_0, .metadata = PC3XX_GPR_AXI2PICO_0, .offset = 8, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_1, .metadata = PC3XX_GPR_AXI2PICO_1, .offset = 9, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_2, .metadata = PC3XX_GPR_AXI2PICO_2, .offset = 10, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_3, .metadata = PC3XX_GPR_AXI2PICO_3, .offset = 11, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_4, .metadata = PC3XX_GPR_AXI2PICO_4, .offset = 12, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_5, .metadata = PC3XX_GPR_AXI2PICO_5, .offset = 13, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_6, .metadata = PC3XX_GPR_AXI2PICO_6, .offset = 14, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_7, .metadata = PC3XX_GPR_AXI2PICO_7, .offset = 15, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_8, .metadata = PC3XX_GPR_AXI2PICO_8, .offset = 16, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_9, .metadata = PC3XX_GPR_AXI2PICO_9, .offset = 17, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_10, .metadata = PC3XX_GPR_AXI2PICO_10, .offset = 18, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_11, .metadata = PC3XX_GPR_AXI2PICO_11, .offset = 19, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_12, .metadata = PC3XX_GPR_AXI2PICO_12, .offset = 20, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_13, .metadata = PC3XX_GPR_AXI2PICO_13, .offset = 21, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_14, .metadata = PC3XX_GPR_AXI2PICO_14, .offset = 22, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_15, .metadata = PC3XX_GPR_AXI2PICO_15, .offset = 23, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_16, .metadata = PC3XX_GPR_AXI2PICO_16, .offset = 24, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_17, .metadata = PC3XX_GPR_AXI2PICO_17, .offset = 25, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_18, .metadata = PC3XX_GPR_AXI2PICO_18, .offset = 26, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_19, .metadata = PC3XX_GPR_AXI2PICO_19, .offset = 27, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_20, .metadata = PC3XX_GPR_AXI2PICO_20, .offset = 28, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_21, .metadata = PC3XX_GPR_AXI2PICO_21, .offset = 29, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_22, .metadata = PC3XX_GPR_AXI2PICO_22, .offset = 30, },
+    { .type = PICO_RES_IRQ, .value = PC3XX_IRQ_AXI2PICO_23, .metadata = PC3XX_GPR_AXI2PICO_23, .offset = 31, },
+    { .type = 0, .value = 0 }, /* Sentinel value. Do not remove and keep this
+                                * at the end. */
+};
+
+/*! The offset in the AXI2Pico for GPR virtual ports. */
+#define AXI2PICO_GPR_VP_START       ( 0x80 )
+
+/*!
+ * Add an IRQ handler to the PC3XX for a given interrupt source.
+ *
+ * @param pa The device to register the interrupt handler with.
+ * @param irq The IRQ to attach the handler to.
+ * @param callback The callback function to call when the interrupt is
+ * raised.
+ * @param cookie The cookie to pass to the callback function. This may be NULL
+ * if it is not required.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_add_irq_handler( struct picoarray *pa,
+                       struct pico_resource *irq,
+                       int ( *callback )( struct pico_resource *irq,
+                                          void *cookie ),
+                       void *cookie )
+{
+    struct pc3xx_irq_handler *handler;
+    struct pc3xx *dev = to_pc3xx( pa );
+    int ret;
+    unsigned gpr_num = irq->value - PC3XX_IRQ_AXI2PICO_0;
+    unsigned offset =
+            AXI2PICO_GPR_VP_START + ( gpr_num * AXI2PICO_VP_SPACING );
+    u32 val = 0;
+    unsigned long flags;
+
+    if ( irq->type != PICO_RES_IRQ || !irq->exclusive || !callback )
+        return -EINVAL;
+
+    spin_lock_irqsave( &pa->lock, flags );
+
+    /* Need to check that the port is bocking before enabling interrupts */
+    pc3xx_axi2pico_reg_read( dev, offset + AXI2PICO_VP_STATUS_OFFSET,
+                             &val);
+
+    /* If the port is non-blocking then fail as we will receive constant
+     * interrupts. We also only support receive GPRs for interrupt
+     * generation. */
+    if ( !IS_PORT_A_RECEIVE( val ) || IS_PORT_NONBLOCKING( val ) )
+    {
+        PRINTD( COMPONENT_PC3XX, DBG_WARN,
+                "cannot enable IRQ: AXI2Pico VP is not"
+                " configured as blocking receive" );
+        PRINTD( COMPONENT_PC3XX, DBG_WARN,"offset=%d",offset);
+        ret = -EIO;
+        goto out;
+    }
+
+    ret = -ENOMEM;
+    handler = kmalloc( sizeof( *handler ), GFP_ATOMIC );
+    if ( !handler )
+        goto out;
+
+    handler->callback   = callback;
+    handler->cookie     = cookie;
+    handler->irq        = irq;
+
+    list_add( &handler->list, &dev->axi2pico_irq_handlers.list );
+
+    /* Enable the interrupt. */
+    pc3xx_axi2pico_reg_read( dev, offset + AXI2PICO_VP_CONFIG_OFFSET, &val );
+    val |= AXI2PICO_INT_EN;
+    pc3xx_axi2pico_reg_write( dev, offset + AXI2PICO_VP_CONFIG_OFFSET, val );
+
+    ret = 0;
+out:
+
+    spin_unlock_irqrestore( &pa->lock, flags );
+    return ret;
+}
+
+
+/*!
+ * Remove an IRQ handler from a PC3XX interrupt source.
+ *
+ * @param pa The PC3XX to remove the handler from.
+ * @param irq The IRQ to remove the handler for.
+ */
+static void
+pc3xx_remove_irq_handler( struct picoarray *pa,
+                          struct pico_resource *irq )
+{
+    struct list_head *pos;
+    struct list_head *tmp;
+    struct pc3xx *dev = to_pc3xx( pa );
+    struct pc3xx_irq_handler *handler;
+    unsigned long flags;
+    unsigned gpr_num = irq->value - PC3XX_IRQ_AXI2PICO_0;
+    unsigned offset =
+            AXI2PICO_GPR_VP_START + ( gpr_num * AXI2PICO_VP_SPACING );
+    u32 val= 0;
+
+    /*
+     * Protect against interrupts being raised whilst we remove the handler.
+     */
+    spin_lock_irqsave( &pa->lock, flags );
+
+    /* Disable the interrupt. */
+    pc3xx_axi2pico_reg_read( dev, offset + AXI2PICO_VP_CONFIG_OFFSET, &val );
+    val &= ~AXI2PICO_INT_EN;
+    pc3xx_axi2pico_reg_write( dev, offset + AXI2PICO_VP_CONFIG_OFFSET, val );
+
+    list_for_each_safe( pos, tmp, &dev->axi2pico_irq_handlers.list )
+    {
+        handler = container_of( pos, struct pc3xx_irq_handler, list );
+        if ( handler->irq == irq )
+        {
+            list_del( pos );
+            break;
+        }
+    }
+
+    spin_unlock_irqrestore( &pa->lock, flags );
+}
+
+/*!
+ * PC3XX AXI2Pico ISR. This ISR will be called when the AXI2Pico generates an
+ * interrupt and checks all of the AXI2Pico interrupt sources for raised
+ * interrupts and calls the appropriate handler if there is one registered. If
+ * there is no interrupt handler for the IRQ source then that source is
+ * disabled.
+ *
+ * @param irq The irq that has been raised.
+ * @param dev The PC3XX device that has raised the interrupt.
+ * @return Returns IRQ_HANDLED on success.
+ */
+static irqreturn_t
+pc3xx_axi2pico_irq( int irq,
+                    void *dev )
+{
+    struct pc3xx *pc3xxdev = dev;
+    struct list_head *pos;
+    struct pc3xx_irq_handler *handler;
+    int ret;
+    u32 int_status;
+    unsigned i;
+    unsigned handled;
+
+    pc3xx_axi2pico_reg_read( pc3xxdev, AXI2PICO_INT_STATUS_OFFSET,
+                             &int_status );
+    for ( i = 0; i < AXI2PICO_NUM_VPS; ++i )
+    {
+        if ( int_status & ( 1 << i ) )
+        {
+            handled = 0;
+            list_for_each( pos, &pc3xxdev->axi2pico_irq_handlers.list )
+            {
+                handler = container_of( pos, struct pc3xx_irq_handler, list );
+                if ( ( handler->irq->offset ) == i  && handler->callback )
+                {
+                    ret = handler->callback( handler->irq, handler->cookie );
+                    if ( !ret )
+                    {
+                        handled = 1;
+                        break;
+                    }
+                }
+            }
+            if ( !handled )
+            {
+                PRINTD( COMPONENT_PC3XX, DBG_WARN,
+                        "no interrupt handler for AXI2Pico VP %u", i );
+                printk("disabling handler for AXI2Pico VP %u", i);
+                /* Disable the interrupt generation for this GPR - there
+                 * is no handler installed. */
+                pc3xx_axi2pico_reg_write( pc3xxdev,
+                       ( i * AXI2PICO_VP_SPACING ) + AXI2PICO_GPR_VP_START,
+                        0 );
+            }
+        }
+    }
+
+    return IRQ_HANDLED;
+}
+
+/*!
+ * Open and enable the specified DMA channel
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to open
+ * @return 0 on success, a negative number on failure
+ */
+static int
+pc3xx_dma_open( struct picoarray *pa,
+                struct pico_resource *dma_channel )
+{
+    struct pc3xx *pc3xxdev = to_pc3xx( pa );
+    struct pc3xx_dma_channel *dma =
+        &pc3xxdev->dma_channel[dma_channel->value];
+    u32 gprStatus = 0;
+
+    if ( dma->stateActive )
+    {
+        PRINTD( COMPONENT_PC3XX, DBG_TRACE, "dma channel %d in use",
+                dma_channel->value - PC3XX_DMA_AXI2PICO_0 );
+        return -EBUSY;
+    }
+
+    PRINTD( COMPONENT_PC3XX, DBG_TRACE,
+            "pa_dma %d  => cpu_dma %d",
+            ( dma_channel->value-PC3XX_DMA_AXI2PICO_0 ),
+            dma_channel->value);
+
+    if ( ( dma_channel->value < PC3XX_DMA_AXI2PICO_0 ) ||
+         ( dma_channel->value > PC3XX_DMA_AXI2PICO_7 ) )
+        return -EINVAL;
+
+    pc3xx_axi2pico_reg_read( pc3xxdev, dma_channel->offset
+              + AXI2PICO_VP_STATUS_OFFSET, &gprStatus );
+
+    if ( !IS_PORT_ENABLED(gprStatus) )
+    {
+        PRINTD( COMPONENT_PC3XX, DBG_ERROR, "dma %d: is not enabled",
+           dma_channel->value);
+        return -EINVAL;
+    }
+
+    /* Set the DMAC Enable bit (bit1) in the DMA config register */
+    if ( IS_PORT_A_RECEIVE(gprStatus) )
+       /* Enable the UL DMA channel by setting bit 1, and set the
+           watermark to 1 x the burst size on bits 2 to 8.  */
+       (void)pc3xx_axi2pico_reg_write( pc3xxdev,
+           ((dma_channel->value - PC3XX_DMA_AXI2PICO_0) * AXI2PICO_VP_SPACING)
+           + AXI2PICO_VP_CONFIG_OFFSET, 0x02 + (PC3XX_DMA_BURST_SIZE << 2));
+    else
+        /* Enable the DL DMA channel by setting bit 1, and set the watermark
+           to 2 x the burst size on bits 2 to 8 */
+        (void)pc3xx_axi2pico_reg_write( pc3xxdev,
+         ((dma_channel->value-PC3XX_DMA_AXI2PICO_0)*AXI2PICO_VP_SPACING)
+         +AXI2PICO_VP_CONFIG_OFFSET, 0x02 + ((2*PC3XX_DMA_BURST_SIZE) << 2));
+
+    return 0;
+}
+
+/*!
+ * Close and disable the specified DMA channel
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to close
+ * @return 0 in all cases
+ */
+static int
+pc3xx_dma_close( struct picoarray *pa,
+                 struct pico_resource *dma_channel )
+{
+    struct pc3xx *pc3xxdev = to_pc3xx( pa );
+    struct pc3xx_dma_channel *dma = &pc3xxdev->dma_channel[dma_channel->value];
+
+    spin_lock_bh( &pa->lock );
+    dma->callback = NULL;
+    dma->stateActive = 0;
+    spin_unlock_bh( &pa->lock );
+
+    return 0;
+}
+
+/*!
+ * DMA handler function. This function simply resets the channel active flag
+ * and passes the cookie onto the handler specified in the pc3xx_to_device
+ * and pc3xx_from_device functions.
+ *
+ * @param cookie The cookie to pass to the callback function.
+ * @return 0 on success, non-zero on failure
+ */
+static void
+pc3xx_dma_handler( void *cookie )
+{
+    struct pc3xx_dma_channel *dma = (struct pc3xx_dma_channel *)cookie;
+
+    PRINTD( COMPONENT_PC3XX, DBG_TRACE, "dma transfer completed" );
+
+    dma->stateActive = 0;
+    dma->curr_desc = NULL;
+
+    if ( dma->callback )
+        dma->callback( dma->cookie, 0 );
+}
+
+/*!
+ * DMA a scatter gather list of memory from a kernel mapped scatterlist
+ * into a picoArray DMA channel. After the DMA transfer has completed, the
+ * callback function will be called with the cookie as the parameter. The
+ * caller of this function is responsible for mapping and unmapping the
+ * buffers to be transferred into a DMA capable region.
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to use as a destination.
+ * @param sgl The scatter gather list of the source data.
+ * @param nents The number of entries in the scatterlist.
+ * @param callback The callback function to be called when the transfer
+ * has completed. The parameter errno will be set to the status of the DMA
+ * operation where 0 == success, negative == failure.
+ * @param cookie The cookie to pass to the callback function.
+ * @return 0 on success, non-zero on failure
+ */
+static int
+pc3xx_dma_to_device( struct picoarray *pa,
+                     struct pico_resource *dma_channel,
+                     struct scatterlist *sgl,
+                     int nents,
+                     int ( *callback )( void *cookie,
+                                        int errno ),
+                     void *cookie )
+{
+    int ret = 0;
+    struct pc3xx *dev = to_pc3xx( pa );
+    struct pc3xx_dma_channel *dma = &dev->dma_channel[dma_channel->value];
+    dma_cookie_t dma_cookie;
+
+    if ( dma->stateActive )
+      return -EAGAIN;
+
+    PRINTD( COMPONENT_DMA, DBG_TRACE, "DMA transfer Chan %d, sgl len %d",
+            dma_channel->value, nents );
+
+    dma->slave.fc = DW_DMA_FC_D_M2P;
+    dma->curr_desc = dma->chan->device->device_prep_slave_sg( dma->chan, sgl,
+                                nents, DMA_TO_DEVICE, DMA_PREP_INTERRUPT );
+    if ( !dma->curr_desc )
+    {
+        PRINTD( COMPONENT_DMA, DBG_WARN, "failed to prep slave transfer" );
+        ret = -EIO;
+        goto out;
+    }
+
+    dma->curr_desc->callback = pc3xx_dma_handler;
+    dma->curr_desc->callback_param = dma;
+
+    dma->stateActive = 1;
+    dma->callback = callback;
+    dma->cookie = cookie;
+
+    dma_cookie = dma->curr_desc->tx_submit( dma->curr_desc );
+    if ( dma_submit_error( dma_cookie ) )
+    {
+        PRINTD( COMPONENT_DMA, DBG_WARN, "failed to start DMA" );
+        ret = -EIO;
+    }
+
+out:
+
+    return ret;
+}
+
+/*!
+ * DMA a scatter gather list of memory from a picoArray DMA channel. After
+ * the DMA transfer has completed, the callback function will be called
+ * with the cookie as the parameter. The caller of this function is
+ * responsible for mapping and unmapping the buffers to be transferred
+ * into a DMA capable region.
+ *
+ * @param pa The picoArray to DMA the data.
+ * @param dma_channel The DMA channel to use as a source.
+ * @param sgl The scatter gather list of the destination buffer.
+ * @param nents The number of entries in the scatterlist.
+ * @param callback The callback function to be called when the transfer
+ * has completed. The parameter errno will be set to the status of the DMA
+ * operation where 0 == success, negative == failure.
+ * @param cookie The cookie to pass to the callback function.
+ * @return 0 on success, non-zero on failure
+ */
+static int
+pc3xx_dma_from_device( struct picoarray *pa,
+                       struct pico_resource *dma_channel,
+                       struct scatterlist *sgl,
+                       int nents,
+                       int ( *callback )( void *cookie,
+                                          int errno ),
+                       void *cookie )
+{
+    int ret = 0;
+    struct pc3xx *dev = to_pc3xx( pa );
+    struct pc3xx_dma_channel *dma = &dev->dma_channel[dma_channel->value];
+    dma_cookie_t dma_cookie;
+
+    if ( dma->stateActive )
+      return -EAGAIN;
+
+    PRINTD( COMPONENT_PC3XX, DBG_TRACE, "DMA transfer Chan %d, sgl len %d",
+          dma_channel->value, nents );
+
+    dma->slave.fc = DW_DMA_FC_D_P2M;
+    dma->curr_desc = dma->chan->device->device_prep_slave_sg( dma->chan, sgl,
+                            nents, DMA_FROM_DEVICE, DMA_PREP_INTERRUPT );
+    if ( !dma->curr_desc )
+    {
+        PRINTD( COMPONENT_PC3XX, DBG_WARN, "failed to prep slave transfer" );
+        ret = -EIO;
+        goto out;
+    }
+
+    dma->curr_desc->callback = pc3xx_dma_handler;
+    dma->curr_desc->callback_param = dma;
+
+    dma->stateActive = 1;
+    dma->callback = callback;
+    dma->cookie = cookie;
+
+    dma_cookie = dma->curr_desc->tx_submit( dma->curr_desc );
+    if ( dma_submit_error( dma_cookie ) )
+    {
+        PRINTD( COMPONENT_DMA, DBG_WARN, "failed to start DMA" );
+        BUG();
+        ret = -EIO;
+    }
+
+    dma->chan->device->device_issue_pending(dma->chan);
+
+out:
+
+    return ret;
+}
+
+/*!
+ * Get the device type of a PC3XX.
+ *
+ * @param pa The device to query.
+ * @return Always returns PICOARRAY_PC3XX.
+ */
+static enum picoarray_device_type
+pc3xx_get_device_type( struct picoarray *pa )
+{
+    return PICOARRAY_PC3XX;
+}
+
+/*! Operations for the PC3XX devices. */
+static struct picoarray_ops pc3xx_ops = {
+    .sync                = pc3xx_sync,
+    .start               = pc3xx_start,
+    .stop                = pc3xx_stop,
+    .get_device_type     = pc3xx_get_device_type,
+    .config_read         = pc3xx_config_read,
+    .config_write        = pc3xx_config_write,
+    .register_read       = pc3xx_register_read,
+    .register_write      = pc3xx_register_write,
+    .reset               = pc3xx_reset,
+    .get_resource        = generic_get_resource,
+    .put_resource        = generic_put_resource,
+    .destructor          = pc3xx_destroy,
+    .add_irq_handler     = pc3xx_add_irq_handler,
+    .remove_irq_handler  = pc3xx_remove_irq_handler,
+    .dma_to_device       = pc3xx_dma_to_device,
+    .dma_from_device     = pc3xx_dma_from_device,
+    .dma_open            = pc3xx_dma_open,
+    .dma_close           = pc3xx_dma_close,
+    .pa_load             = pc3xx_pa_load,
+};
+
+static bool
+dma_filter( struct dma_chan *chan,
+            void *param )
+{
+    struct dw_dma_slave *dws = param;
+
+    if ( !strcmp( dev_name( chan->device->dev ), "dw_dmac.0" ) )
+    {
+        chan->private = dws;
+        return true;
+    }
+
+    return false;
+}
+
+static int
+pc3xx_alloc_dma_channels( struct pc3xx *newdev )
+{
+    struct pc3xx_dma_channel *dma;
+    int i;
+    dma_cap_mask_t mask;
+
+    for ( i = 0; i < PICO_NUM_DMA_CHANNELS; ++i )
+    {
+        dma = &newdev->dma_channel[ i ];
+
+        dma->pico_addr = ( dma_addr_t )newdev->axi2pico_base_phys +
+            ( i * AXI2PICO_VP_SPACING) + AXI2PICO_VP_DATA_OFFSET;
+
+        /* Initialise all variables that may become set */
+        dma_cap_zero( mask );
+        dma_cap_set( DMA_SLAVE, mask );
+        dma->slave = ( struct dw_dma_slave ) {
+            .tx_reg     = dma->pico_addr,
+            .rx_reg     = dma->pico_addr,
+            .reg_width  = DW_DMA_SLAVE_WIDTH_32BIT,
+            .cfg_hi     = DWC_CFGH_DST_PER( i ) |
+                          DWC_CFGH_SRC_PER( i ),
+            .cfg_lo     = 0,
+            .src_master = ( i + 1 ) & 0x3,
+            .dst_master = i & 0x3,
+            .dma_dev    = newdev->axi2pico_dmac,
+        };
+
+        dma->chan = dma_request_channel( mask, dma_filter, &dma->slave );
+        if ( !dma->chan )
+        {
+            PRINTD( COMPONENT_PC3XX, DBG_ERROR, "failed to open dma channel" );
+            return -ENODEV;
+        }
+        dma->slave.tx_reg = dma->pico_addr;
+        dma->slave.rx_reg = dma->pico_addr;
+
+        dma->channel = i;
+        dma->stateActive = 0;
+        dma->callback = NULL;
+        dma->cookie = NULL;
+    }
+
+    return 0;
+}
+
+/*!
+ * Probe method for the PC3XX platform driver. This function creates a new
+ * PC3XX instance and is responsible for allocating all of the resources
+ * required.
+ *
+ * @param pdev The platform device that has been probed.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_probe( struct platform_device *pdev )
+{
+    struct resource *res;
+    int ret;
+    struct pc3xx *newdev = kzalloc( sizeof( *newdev ), GFP_KERNEL );
+    struct pc3xx_pdata *pc3xx_dmacs = pdev->dev.platform_data;
+
+    if ( !newdev )
+        return -ENOMEM;
+
+    device_init_wakeup( &pdev->dev, 1 );
+
+    ret = -ENOMEM;
+    newdev->pa.resources = kmalloc( sizeof( pc3xx_resources ), GFP_KERNEL );
+    if ( !newdev->pa.resources )
+        goto out;
+    memcpy( newdev->pa.resources, pc3xx_resources, sizeof( pc3xx_resources ) );
+
+    newdev->pa.dev_num = pdev->id;
+    newdev->pa.ops = &pc3xx_ops;
+    newdev->pa.features = PICOARRAY_HAS_DMA;
+    newdev->pa.max_dma_sz = PICOARRAY_MAX_TRANSFER;
+    newdev->axi2pico_dmac = pc3xx_dmacs->axi2pico_dmac;
+    newdev->axi2cfg_dmac = pc3xx_dmacs->axi2cfg_dmac;
+    spin_lock_init( &newdev->pa.lock );
+
+    ret = -EINVAL;
+
+    /* Get the IRQ for AXI2Pico GPRs. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_IRQ, "gpr_irq" );
+    if ( !res )
+        goto out;
+    newdev->gpr_irq = res->start;
+
+    /* Get the register base address for the lower AXI2CFG registers */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM, "procif" );
+    if ( !res )
+        goto out;
+    newdev->axi2cfg1_base_phys = res->start;
+    newdev->axi2cfg1_base_len = ( res->end - res->start ) + 1;
+
+    /* Get the register base address for the upper AXi2CFG registers */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM,
+                                        "procif2" );
+    if ( !res )
+        goto out;
+    newdev->axi2cfg2_base_phys = res->start;
+    newdev->axi2cfg2_base_len = ( res->end - res->start ) + 1;
+
+    /* Get the register base address for the AXI2Pico. */
+    res = platform_get_resource_byname( pdev, IORESOURCE_MEM,
+                                        "ahb2pico_axi2pico" );
+    if ( !res )
+        goto out;
+    newdev->axi2pico_base_phys = res->start;
+    newdev->axi2pico_base_len = ( res->end - res->start ) + 1;
+
+    /* Map the resources. */
+    newdev->axi2cfg1_base = request_and_map( "axi2cfg1", newdev->axi2cfg1_base_phys,
+                                        newdev->axi2cfg1_base_len );
+    if ( !newdev->axi2cfg1_base )
+        goto out;
+
+    newdev->axi2pico_base = request_and_map( "axi2pico", newdev->axi2pico_base_phys,
+                                        newdev->axi2pico_base_len );
+    if ( !newdev->axi2pico_base )
+        goto ahb2pico_map_failed;
+
+    ret = request_irq( newdev->gpr_irq, pc3xx_axi2pico_irq, IRQF_DISABLED,
+                       pdev->name, newdev );
+    if ( ret )
+        goto axi2pico_irq_failed;
+
+    device_init_wakeup( &pdev->dev, 1 );
+    if ( pc3xx_alloc_dma_channels( newdev ) )
+    {
+        ret = -EBUSY;
+        goto dma_channels_failed;
+    }
+
+    /* Initialise the interrupt handler lists. */
+    INIT_LIST_HEAD( &newdev->axi2pico_irq_handlers.list );
+
+    ret = picoif_register_dev( &newdev->pa );
+    goto out;
+
+dma_channels_failed:
+    free_irq( newdev->gpr_irq, newdev );
+
+axi2pico_irq_failed:
+    unmap_and_release( newdev->axi2pico_base_phys, newdev->axi2pico_base_len,
+                       newdev->axi2pico_base );
+
+ahb2pico_map_failed:
+    unmap_and_release( newdev->axi2cfg1_base_phys, newdev->axi2cfg1_base_len,
+                       newdev->axi2cfg1_base );
+out:
+    if ( ret && newdev->pa.resources )
+        kfree( newdev->pa.resources );
+
+    if ( ret )
+        kfree( newdev );
+    else
+        ++num_pc3xxs;
+
+    return ret;
+}
+
+/*!
+ * Remove method for the PC3XX platform driver. This method is called when the
+ * platform driver is removed and must release all resources the driver has
+ * been using.
+ *
+ * @param pdev The platform device being remove.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+pc3xx_remove( struct platform_device *pdev )
+{
+    struct picoarray *pa = picoif_get_device( pdev->id );
+    struct pc3xx *pc3xxdev = to_pc3xx( pa );
+    int ret = 0, i = 0;
+
+    for ( i = 0; i < PICO_NUM_DMA_CHANNELS; ++i )
+    {
+        if ( pc3xxdev->dma_channel[ i ].chan )
+            dma_release_channel( pc3xxdev->dma_channel[ i ].chan );
+    }
+
+    free_irq( pc3xxdev->gpr_irq, pc3xxdev );
+    unmap_and_release( pc3xxdev->axi2cfg1_base_phys, pc3xxdev->axi2cfg1_base_len,
+                       pc3xxdev->axi2cfg1_base );
+    unmap_and_release( pc3xxdev->axi2pico_base_phys, pc3xxdev->axi2pico_base_len,
+                       pc3xxdev->axi2pico_base );
+
+    kfree( pc3xxdev );
+
+    return ret;
+}
+
+/*! The PC3XX platform driver.
+ *  \todo Change the name to PC3XX specific rather than generic picoArray.
+ */
+static struct platform_driver pc3xx_driver = {
+    .probe      = pc3xx_probe,
+    .remove     = pc3xx_remove,
+    .driver     = {
+        .name   = "picoArray",
+    },
+};
+
+int
+pc3xx_init( void )
+{
+    return platform_driver_register( &pc3xx_driver );
+}
+
+/*!
+ * Destructor to be called when a PC3XX is removed from picoif. This
+ * function must decrement the number of PC3XXs registered, and when this
+ * reaches zero, remove the platform driver.
+ *
+ * @param pa The device being removed.
+ */
+static void
+pc3xx_destroy( struct picoarray *pa )
+{
+    PRINTD( COMPONENT_PC3XX, DBG_TRACE, "pA[%u]: destructor called",
+            pa->dev_num );
+
+    /* If we have no more pc3xxs, then remove the driver. */
+    if ( 0 == --num_pc3xxs )
+        platform_driver_unregister( &pc3xx_driver );
+}
diff --git a/drivers/picochip/picoarray.h b/drivers/picochip/picoarray.h
new file mode 100644
index 0000000..2c350a9
--- /dev/null
+++ b/drivers/picochip/picoarray.h
@@ -0,0 +1,470 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoarray.h
+ * \brief picoArray device and resource definition.
+ *
+ * This file defines a base class for a picoArray and a resource type used for
+ * accessing picoArray resources. This base class should not be instantiated
+ * directly but inherited from to create specific device types (using the
+ * container_of()) macro.
+ */
+
+/*!
+ * \page paAbstraction picoArray Class Hierarchy
+ *
+ * \section introduction Introduction
+ *
+ * Each type of picoArray is implemented as a class derived from the picoarray
+ * base class and must contain the methods in picoarray_ops. The picoarray
+ * structure consists of 3 main components:
+ *  \li Resources
+ *  \li Operations
+ *  \li Common members
+ *
+ * The resources describe the DMA channels, GPRs and interrupt sources that
+ * the picoArray has. Users should never directly access these resources -
+ * they should use the get_resource and put_resource methods of the
+ * picoarray_ops to get and release the resources. Using these resources,
+ * upper layers such as transport methods can hold exclusive access to a
+ * resource and prevent conflicts between transport instances and methods and
+ * also prevent other user applications from disrupting a transport service.
+ * Consider the HwIf transport as an example. There are several GPRs used for
+ * signalling the amount of data available to transfer, the amount of data the
+ * host processor has queued for transfer and for clearing interrupts. If a
+ * user application did a register write to the count GPR, then the reference
+ * design would lose synchronisation with the application and data
+ * loss/corruption could occur. By adding these resources and locks, if the
+ * transport needs exclusive access, then this is guaranteed by the resources.
+ *
+ * The operations define a set of primitive operations that effectively export
+ * the basic services that the picoArray can provide. For some device types,
+ * some services may be unavailable in which case the operations should still
+ * be implemented but always return an error. These services include
+ * primitives such as configuration bus access, GPR access, IRQ registration
+ * and DMA to/from device methods. As an example use of these services, a DMA
+ * transport module would be responsible for managing the data that needs to
+ * be transferred to/from the picoArray and when a transfer needs to take
+ * place, the module will call the dma_to_device() or dma_from_device()
+ * operation in the relevant picoArray.
+ *
+ * The common members include the logical device number, spin locks for
+ * concurrent access and pointers to the resources and operations. These
+ * common members should contain no device specific information.
+ *
+ * \section new_devices Adding new devices
+ *
+ * To add a new device type, an implementation file for the device should be
+ * created, for example pc3xx.c. This file contains the derived structure -
+ * pc02d has the picoarray structure embedded in it. The PC3XX methods
+ * are also defined, and these can get a pc3xx pointer from a pointer to the
+ * embedded picoarray structure with the container_of() macro:
+ *
+ * \code
+ *  struct picoarray *pa;
+ *  struct pc3xx *pc3xxdev = container_of( pa, struct pc3xx, pa );
+ * \endcode
+ *
+ * This file also needs to define the resources that the device has and must
+ * provide init() and destructor functions that are used to register the
+ * device with picoIf and remove the driver when picoIf is unloaded.
+ */
+#ifndef __PICOIF_PICOARRAY_H__
+#define __PICOIF_PICOARRAY_H__
+
+#include <linux/types.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+struct picoarray;
+
+/*!
+ * picoArray device types.
+ */
+enum picoarray_device_type
+{
+    PICOARRAY_PC3XX,
+};
+
+/*!
+ * \brief Enumeration for picoArray resource types.
+ *
+ * This defines resource types for picoArray resources that may be requested
+ * by functions. Each device type should have a corresponding enumeration for
+ * each type that lists all resources the device has.
+ */
+enum pico_resource_type
+{
+    PICO_RES_DMA_CHANNEL = 1,  /*!< DMA channel. */
+    PICO_RES_GPR,              /*!< General purpose register (GPR). */
+    PICO_RES_IRQ,              /*!< IRQ source. */
+};
+
+/*!
+ * \brief A resource descriptor describing a picoArray resource.
+ *
+ * This structure defines a resource for a picoArray and should not be
+ * accessed directly.
+ */
+struct pico_resource
+{
+    enum pico_resource_type type;       /*!< The resource type. */
+
+    unsigned                value;      /*!< The resource ID/value. */
+
+    int                     exclusive;  /*!< Boolean flag to indicate the
+                                         *  resource is exclusively held. */
+
+    atomic_t                ref_count;  /*!< The reference count of the
+                                         *  resource. */
+
+    unsigned                offset;     /*!< For GPRs and DMA channels, this is
+                                         *  the offset. For interrupts this
+                                         *  fields usage is dependent on the
+                                         *  IRQ type. */
+
+    int                     metadata;   /*!< Metadata for the resource. For GPR
+                                         * interrupts, this may be the GPR that
+                                         * the interrupt is tied to. */
+};
+
+/*!
+ * \brief Operations common to all picoArray devices.
+ *
+ * This structure defines a set of operations that all picoArrays should
+ * support. These functions are used for configuration and transport but only
+ * provide primitive services. More complicated transports should use these
+ * functions to implement a higher level transport module.
+ */
+struct picoarray_ops
+{
+    /*!
+     * Get the picoArray device type.
+     *
+     * @return Returns the picoArray device type.
+     */
+    enum picoarray_device_type ( *get_device_type )( struct picoarray *pa );
+
+    /*!
+     * Reset the device.
+     *
+     * @param pa The device to reset.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *reset )( struct picoarray *pa );
+
+    /*!
+     * Start the device.
+     *
+     * @param pa The device to start.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *start )( struct picoarray *pa );
+
+    /*!
+     * Sync the device.
+     *
+     * @param pa The device to sync.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *sync )( struct picoarray *pa );
+
+    /*!
+     * Stop the device.
+     *
+     * @param pa The device to stop.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *stop )( struct picoarray *pa );
+
+    /*!
+     * Perform a read from the configuration bus.
+     *
+     * @param pa The device to read from.
+     * @param caeid The CAEID of the AE to read from.
+     * @param address The address from within the AE to begin reading from.
+     * @param count The number of 16-bit words to read.
+     * @param data Pointer to the buffer to write the words read into.
+     * @return Returns the number of 16-bit words read on success, negative on
+     * failure.
+     */
+    int ( *config_read )( struct picoarray *pa,
+                          u16 caeid,
+                          u16 address,
+                          u16 count,
+                          u16 *data );
+
+    /*!
+     * Perform a write to the configuration bus.
+     *
+     * @param pa The device to write to.
+     * @param caeid The CAEID of the AE to write to.
+     * @param address The address from within the AE to begin writing from.
+     * @param count The number of 16-bit words to write.
+     * @param data Pointer to the buffer of words to write.
+     * @return Returns the number of 16-bit words written on success, negative
+     * on failure.
+     */
+    int ( *config_write )( struct picoarray *pa,
+                           u16 caeid,
+                           u16 address,
+                           u16 count,
+                           u16 *data );
+
+    /*!
+     * Perform multiple write to the configuration bus write register.
+     *
+     * @param pa The device to write to.
+     * @param data Pointer to the buffer of words to write.
+     * @param sgl The scatter gather list of the source data.
+     * @return Returns the number of 32-bit words written on success, negative
+     * on failure.
+     */
+    int ( *pa_load )( struct picoarray *pa,
+                      u32 *data,
+                      struct scatterlist *sgl );
+
+    /*!
+     * DMA a scatter gather list of memory from a kernel mapped scatterlist
+     * into a picoArray DMA channel. After the DMA transfer has completed, the
+     * callback function will be called with the cookie as the parameter. The
+     * caller of this function is responsible for mapping and unmapping the
+     * buffers to be transferred into a DMA capable region.
+     *
+     * @param pa The picoArray to DMA the data.
+     * @param dma_channel The DMA channel to use as a destination.
+     * @param sgl The scatter gather list of the source data.
+     * @param nents The number of entries in the scatterlist.
+     * @param callback The callback function to be called when the transfer
+     * has completed. The parameter errno will be set to the status of the DMA
+     * operation where 0 == success, negative == failure.
+     * @param cookie The cookie to pass to the callback function.
+     * @return Returns the number of bytes queued for transfer on success,
+     * negative on failure. Note that it is possible that the number of bytes
+     * queued may not be the same as nbytes if the device does not support
+     * scatter gather operations.
+     */
+    int ( *dma_to_device )( struct picoarray *pa,
+                            struct pico_resource *dma_channel,
+                            struct scatterlist *sgl,
+                            int nents,
+                            int ( *callback )( void *cookie,
+                                               int errno ),
+                            void *cookie );
+
+    /*!
+     * DMA a scatter gather list of memory from a picoArray DMA channel. After
+     * the DMA transfer has completed, the callback function will be called
+     * with the cookie as the parameter. The caller of this function is
+     * responsible for mapping and unmapping the buffers to be transferred
+     * into a DMA capable region.
+     *
+     * @param pa The picoArray to DMA the data.
+     * @param dma_channel The DMA channel to use as a source.
+     * @param sgl The scatter gather list of the destination buffer.
+     * @param nents The number of entries in the scatterlist.
+     * @param callback The callback function to be called when the transfer
+     * has completed. The parameter errno will be set to the status of the DMA
+     * operation where 0 == success, negative == failure.
+     * @param cookie The cookie to pass to the callback function.
+     * @return Returns the number of bytes queued for transfer on success,
+     * negative on failure. Note that it is possible that the number of bytes
+     * queued may not be the same as nbytes if the device does not support
+     * scatter gather operations.
+     */
+    int ( *dma_from_device )( struct picoarray *pa,
+                              struct pico_resource *dma_channel,
+                              struct scatterlist *sgl,
+                              int nents,
+                              int ( *callback )( void *cookie,
+                                                 int errno ),
+                              void *cookie );
+
+    /*!
+     * Open and enables a DMA channel
+     *
+     * @param pa The picoArray to DMA the data.
+     * @param dma_channel The DMA channel to use as a source.
+     * @return Returns 0 on success, negative on failure.
+     */
+    int ( *dma_open )( struct picoarray *pa,
+                       struct pico_resource *dma_channel );
+
+    /*!
+     * Closes and disables a DMA channel
+     *
+     * @param pa The picoArray to DMA the data.
+     * @param dma_channel The DMA channel to use as a source.
+     * @return Returns 0 on success, negative on failure.
+     */
+    int ( *dma_close )( struct picoarray *pa,
+                        struct pico_resource *dma_channel );
+
+    /*!
+     * Read the value of a general purpose register (GPR). The register is
+     * referenced by the resource which must be retrieved with get_resource.
+     * If the register is being used exclusively by a transport and the
+     * get_resource fails, the register cannot be read.
+     *
+     * @param pa The device to read from.
+     * @param reg The register to read.
+     * @param value Pointer to the address the value should be stored in.
+     * @return Returns the resource on success, NULL on failure.
+     */
+     int ( *register_read )( struct picoarray *pa,
+                             struct pico_resource *reg,
+                             u32 *value );
+
+    /*!
+     * Write the value of a general purpose register (GPR). The register is
+     * referenced by the resource which must be retrieved with get_resource.
+     * If the register is being used exclusively by a transport and the
+     * get_resource fails, the register cannot be read.
+     *
+     * @param pa The device to write to.
+     * @param reg The register to write.
+     * @param value The value of the register to write.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *register_write )( struct picoarray *pa,
+                             struct pico_resource *reg,
+                             u32 value );
+
+    /*!
+     * Add a new IRQ handler. There must only be 1 IRQ handler for each
+     * interrupt source so the resource must have the exclusive flag set. The
+     * callback will be called when the interrupt is raised and must the
+     * interrupt must be cleared by the callback. The callback will be called
+     * in interrupt context and so should run as quickly as possible and may
+     * not sleep. If more processing is required, this should be deferred to a
+     * tasklet or work queue.
+     *
+     * @param pa The device to register the handler for.
+     * @param irq The IRQ source to handle.
+     * @param callback The callback function to call when the IRQ is raised.
+     * @param cookie A cookie to pass to the callback function.
+     * @return Returns zero on success, negative on failure.
+     */
+    int ( *add_irq_handler )( struct picoarray *pa,
+                              struct pico_resource *irq,
+                              int ( *callback )( struct pico_resource *irq,
+                                                 void *cookie ),
+                              void *cookie );
+
+    /*!
+     * Remove an interrupt handler from the device.
+     *
+     * @param pa The device to remove the interrupt handler from.
+     * @param irq The interrupt source to remove the handler for.
+     */
+    void ( *remove_irq_handler )( struct picoarray *pa,
+                                  struct pico_resource *irq );
+
+    /*!
+     * Get a resource from the device. This will increment the reference count
+     * of the resource, and if it exclusive access is requested, the exclusive
+     * flag will be set and further attempts to get the resource will fail
+     * until the reference count has been decremented back to zero.
+     *
+     * @param pa The device to get the resource from.
+     * @param resource_type The type of resource being requested.
+     * @param resource_id The ID of the resource being requested.
+     * @param exclusive Boolean flag indicating whether exclusive access is
+     * required.
+     * @return Returns a pointer to the resource on success, NULL on failure.
+     */
+    struct pico_resource * ( *get_resource )( struct picoarray *pa,
+                                        enum pico_resource_type resource_type,
+                                        unsigned resource_id,
+                                        int exclusive );
+
+    /*!
+     * Decrement the reference count of a resource. If the resource is held
+     * exclusively and the reference count is zero after decrementing, it will
+     * become available to other users.
+     *
+     * @param pa The device the resource belongs to.
+     * @param resource The resource to put.
+     */
+    void ( *put_resource )( struct picoarray *pa,
+                            struct pico_resource *resource );
+
+    /*!
+     * Destructor for the device. This function is called when the module
+     * releases the devices and should be used for any cleanup needed.
+     *
+     * @param pa The device to destroy.
+     */
+    void ( *destructor )( struct picoarray *pa );
+};
+
+/*!
+ * \brief Base class for picoArray structures.
+ *
+ * This is an abstract base class for picoArray structures and there should
+ * never be any standalone instances of this structure - they should be
+ * contained in device specific structures to inherit from this using
+ * container_of() macros.
+ */
+struct picoarray
+{
+    unsigned                dev_num;    /*!< The logical device number of the
+                                         *   picoArray. */
+
+    struct picoarray_ops    *ops;       /*!< Methods for the device. */
+
+    struct pico_resource    *resources; /*!< Resources that the device has.
+                                         *   This is an array of resources and
+                                         *   should be terminated with a 0
+                                         *   filled entry. */
+
+    spinlock_t              lock;       /*!< Concurrency lock. This is used
+                                         *   for protecting resources and
+                                         *   hardware interlocks. */
+
+    unsigned long           features;   /*!< Features bitmap. Used to indicate
+                                         *   features that the device supports
+                                         */
+    unsigned long           max_dma_sz; /*!< Maximum DMA transfer length. */
+};
+
+#define PICOARRAY_HAS_DMA_LOAD          ( 1 << 0 )
+#define PICOARRAY_HAS_DMA               ( 1 << 1 )
+
+/*!
+ * Check if a picoArray has a requested feature.
+ *
+ * \param pa The picoArray to query.
+ * \param feature The feature to test for.
+ * \return Returns non-zero if the device has the feature, zero otherwise.
+ */
+static inline int
+picoarray_has_feature( const struct picoarray *pa,
+                       unsigned long feature )
+{
+    return pa->features & feature;
+}
+
+/*!
+ * Init function for the PC3XX device family. This must be called by
+ * picoif_main to allow the PC3XX devices (if any) to be detected.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+int
+pc3xx_init( void );
+
+#endif /* !__PICOIF_PICOARRAY_H__ */
diff --git a/drivers/picochip/picoif_internal.h b/drivers/picochip/picoif_internal.h
new file mode 100644
index 0000000..4375db0
--- /dev/null
+++ b/drivers/picochip/picoif_internal.h
@@ -0,0 +1,184 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif_internal.h
+ * \brief Internal operations for picoIf driver implementation.
+ *
+ * This file defines functions in the picoIf core used for registering
+ * transport modules, and accessing core module services.
+ *
+ * \mainpage
+ *
+ * This document describes the architecture and implementation of the picoIf
+ * Linux kernel driver. This document also describes the kernel API available
+ * to users.
+ *
+ * \section Overview
+ *
+ * picoIf is a library and driver to allow users to configure, control and
+ * communicate with picoArray devices. This documentation describes the driver
+ * implementation and kernel space API but the driver also provides a
+ * userspace interface through POSIX system calls, and debugfs.
+ *
+ * For more details, see:
+ * \li \ref moduleDocs
+ * \li \ref paAbstraction
+ * \li \ref kernelAPI
+ * \li \ref debugging
+ */
+#ifndef __PICOIF_PICOIF_INTERNAL_H__
+#define __PICOIF_PICOIF_INTERNAL_H__
+
+#include <asm/io.h>
+#include "picoarray.h"
+
+struct picoif_module;
+
+/*! Accessor for struct picoif_buf to get the user buffer address. */
+#define ubuf    buf_u.u_buf
+/*! Accessor for struct picoif_buf to get the kernel buffer address. */
+#define kbuf    buf_u.k_buf
+
+/*!
+ * \brief Structure to abstract user/kernel buffer spaces.
+ */
+struct picoif_buf
+{
+    /*! The buffer pointers. u_buf if .is_user = 1, k_buf otherwise. */
+    union
+    {
+        void __user *u_buf;
+        void        *k_buf;
+    } buf_u;
+
+    /*! Boolean flag to indicate the buffer is a userspace buffer. */
+    int             is_user;
+};
+
+/*!
+ * Copy the contents of a struct picoif_buf into a kernel buffer. This is
+ * used to allow functions to work for either userspace or kernel space
+ * interfaces with a simple wrapper around them to create the struct
+ * picoif_buf.
+ *
+ * @param dst The buffer to copy the data into.
+ * @param src The buffer to copy the data from.
+ * @param offset The byte offset in src to begin copying from.
+ * @param nbytes The number of bytes to copy from src to dst.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_buf_copy_from( void *dst,
+                      struct picoif_buf *src,
+                      unsigned offset,
+                      size_t nbytes );
+
+/*!
+ * Copy the contents of a kernel buffer into a struct picoif_buf. This is
+ * used to allow functions to work for either userspace or kernel space
+ * interfaces with a simple wrapper around them to create the struct
+ * picoif_buf.
+ *
+ * @param dst The buffer to copy the data into.
+ * @param src The buffer to copy the data from.
+ * @param offset The byte offset in dst to begin copying to.
+ * @param nbytes The number of bytes to copy from src to dst.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_buf_copy_to( struct picoif_buf *dst,
+                    void *src,
+                    unsigned offset,
+                    size_t nbytes );
+
+/*!
+ * Register a new device with picoif.
+ *
+ * @param pa The new device to register with the module.
+ * @return Returns zero on success, non-zero on failure.
+ */
+int
+picoif_register_dev( struct picoarray *pa );
+
+/*!
+ * Unregister a device from the module.
+ *
+ * @param pa The device to unregister from the module.
+ */
+void
+picoif_unregister_dev( struct picoarray *pa );
+
+/*!
+ * Register a new picoif module with the driver. This module should be
+ * used to provide new transport methods. Modules are unregistered with
+ * picoif_unregister_module().
+ *
+ * @param module The module to register with the driver.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_register_module( struct picoif_module *module );
+
+/*!
+ * Unregister a transport module from the driver.
+ *
+ * @param module The module to unregister.
+ */
+void
+picoif_unregister_module( struct picoif_module *module );
+
+/*!
+ * Get a device given its logical device number.
+ *
+ * @param dev_num The logical device number of the picoArray to get.
+ * @return Returns a pointer to the device on success, NULL on failure.
+ */
+struct picoarray *
+picoif_get_device( unsigned dev_num );
+
+/*!
+ * Perform a 32 bit write to the picoArray taking endianness into account.
+ *
+ * @param value The value to write.
+ * @param addr The virtual IO address to write to.
+ */
+static inline void
+picoif_out32( u32 value,
+              void __iomem *addr )
+{
+#ifdef __LITTLE_ENDIAN
+    iowrite32( value, addr );
+#else /* __LITTLE_ENDIAN */
+    out_be32( addr, value );
+#endif /* __LITTLE_ENDIAN */
+}
+
+/*!
+ * Perform a 32 bit read from the picoArray taking endianness into account.
+ *
+ * @param addr The virtual IO address to read from.
+ * @return Returns the 32 bit value.
+ */
+static inline u32
+picoif_in32( void __iomem *addr )
+{
+#ifdef __LITTLE_ENDIAN
+    return ioread32( addr );
+#else /* __LITTLE_ENDIAN */
+    return in_be32( addr );
+#endif /* __LITTLE_ENDIAN */
+}
+
+#endif /* !__PICOIF_PICOIF_INTERNAL_H__ */
diff --git a/drivers/picochip/picoif_main.c b/drivers/picochip/picoif_main.c
new file mode 100644
index 0000000..82ce5ac
--- /dev/null
+++ b/drivers/picochip/picoif_main.c
@@ -0,0 +1,1509 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif_main.c
+ * \brief Main file for picoIf kernel driver.
+ *
+ * This file implements the core functionality of the picoIf kernel driver.
+ * This file is responsible for registration of devices and transport modules
+ * and handling all userspace/kernelspace interfaces such as file operations.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/err.h>
+#include <linux/debugfs.h>
+#include <linux/poll.h>
+#include <linux/aio.h>
+#include <linux/dma-mapping.h>
+#include <linux/picochip/picoif.h>
+#include <linux/picochip/picoif_ioctl.h>
+
+#include "debug.h"
+#include "directdma_internal.h"
+#include "dma_fifo_internal.h"
+#include "dma_internal.h"
+#include "gpr_interrupt_internal.h"
+#include "hwif2_internal.h"
+#include "picoarray.h"
+#include "picoif_internal.h"
+#include "picoif_module.h"
+
+/*! The maximum number of devices the driver supports. */
+#define PICOIF_MAX_DEVICES ( 8 )
+
+/*! The maximum number of transport modules the driver supports. */
+#define PICOIF_MAX_MODULES ( 8 )
+
+/*! The maximum number of bytes to be transfered between user and
+ *  kernel space in one operation. This number must take into account
+ *  any DMA tranaction limits that exist if DMA is being used */
+#define PICOIF_MAX_TRANSFER_SIZE ( 4096 )
+
+/*!
+ * \brief Structure to store devices in the system and any other data private
+ * to the driver.
+ */
+struct picoif_core_t
+{
+    /*! The devices that the driver interfaces to. */
+    struct picoarray            *devices[ PICOIF_MAX_DEVICES ];
+
+    /*! The miscdevice used for the Linux device registration. */
+    struct miscdevice           miscdev;
+
+    /*! The modules that have been registered with picoIf. */
+    struct picoif_module        *modules[ PICOIF_MAX_MODULES ];
+
+#ifdef CONFIG_DEBUG_FS
+    /*! The entry in /debug for all debugfs files. */
+    struct dentry               *debugfs_dir;
+
+    /*! The entry in /debug/picoif for the debug log. */
+    struct dentry               *debug_log;
+#endif /* CONFIG_DEBUG_FS */
+};
+
+static int
+picoif_open( struct inode *inode,
+             struct file *filp );
+
+static ssize_t
+picoif_write( struct file *filp,
+              const char __user *buf,
+              size_t len,
+              loff_t *loff );
+
+static ssize_t
+picoif_read( struct file *filp,
+             char __user *buf,
+             size_t len,
+             loff_t *loff );
+
+static long
+picoif_ioctl( struct file *filp,
+              unsigned int cmd,
+              unsigned long arg );
+
+static int
+picoif_release( struct inode *inode,
+                struct file *filp );
+
+static int
+picoif_mmap( struct file *filp,
+             struct vm_area_struct *vma );
+
+static unsigned int
+picoif_poll( struct file *filp,
+             struct poll_table_struct *pollt );
+
+static ssize_t
+picoif_aio_write( struct kiocb *iocb,
+                  const struct iovec *vecs,
+                  unsigned long nr_segs,
+                  loff_t offset );
+
+static ssize_t
+picoif_aio_read( struct kiocb *iocb,
+                 const struct iovec *vecs,
+                 unsigned long nr_segs,
+                 loff_t offset );
+
+/*!
+ * File operations structure for the driver. All file operations for the
+ * driver and transports will be in this structure and if the operation needs
+ * to be rerouted to a transport module, this will happen in these functions.
+ */
+static struct file_operations picoif_fops = {
+    .owner	    = THIS_MODULE,
+    .open           = picoif_open,
+    .release        = picoif_release,
+    .write          = picoif_write,
+    .read           = picoif_read,
+    .unlocked_ioctl = picoif_ioctl,
+    .mmap	    = picoif_mmap,
+    .poll           = picoif_poll,
+    .aio_read       = picoif_aio_read,
+    .aio_write      = picoif_aio_write,
+};
+
+/*!
+ * The miscdevice for the driver.
+ */
+static struct picoif_core_t picoif_core = {
+    .miscdev    =  {
+        .fops   = &picoif_fops,
+        .name   = "picoif",
+        .minor  = MISC_DYNAMIC_MINOR,
+    },
+};
+
+int
+picoif_buf_copy_from( void *dst,
+                      struct picoif_buf *src,
+                      unsigned offset,
+                      size_t nbytes )
+{
+    if ( src->is_user )
+        return copy_from_user( dst, src->ubuf + offset, nbytes );
+
+    return memcpy( dst, src->kbuf + offset, nbytes ) ? 0 : 1;
+}
+
+int
+picoif_buf_copy_to( struct picoif_buf *dst,
+                    void *src,
+                    unsigned offset,
+                    size_t nbytes )
+{
+    if ( dst->is_user )
+        return copy_to_user( dst->ubuf + offset, src, nbytes );
+
+    return memcpy( dst->kbuf + offset, src, nbytes ) ? 0 : 1;
+}
+
+/*!
+ * Open a new instance of the driver. At open, the file descriptor will be a
+ * generic picoif instance for configuration and to use it as a transport
+ * file descriptor, the NEW_TRANSPORT ioctl() call must be used to associate
+ * it with a transport instance.
+ *
+ * @param inode The inode of the device file.
+ * @param filp The context of the open instance. The private_data member can
+ * be used to store driver information for this context. For non-transport
+ * instances, private_data should be NULL and for transport instances it
+ * should point to a struct picoif_context.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_open( struct inode *inode,
+             struct file *filp )
+{
+    filp->private_data = NULL;
+    return 0;
+}
+
+/*!
+ * Close an instance of the driver. If this descriptor is associated with a
+ * transport, close the transport instance.
+ *
+ * @param inode The inode of the device file.
+ * @param filp The context of the open instance.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_release( struct inode *inode,
+                struct file *filp )
+{
+    struct picoif_context *ctx = filp->private_data;
+
+    /* If this is a transport instance, close it. */
+    if ( ctx )
+        ctx->module->ops->close_instance( ctx->module, ctx );
+
+    return 0;
+}
+
+/*!
+ * Asynchronous write operation for picoIf. We don't actually do any
+ * asynchronous operations, but this is also used for the writev() system call
+ * so we simply complete these operations synchronously.
+ *
+ * @param iocb The IO control buffer for the request.
+ * @param vecs The vector of buffers to write.
+ * @param nr_segs The number of entries in the vecs buffer to write.
+ * @param offset Not used in this driver.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+static ssize_t
+picoif_aio_write( struct kiocb *iocb,
+                  const struct iovec *vecs,
+                  unsigned long nr_segs,
+                  loff_t offset )
+{
+    ssize_t ret = 0;
+    struct picoif_context *ctx = iocb->ki_filp->private_data;
+    if ( !ctx )
+        return -EBADF;
+
+    if ( ctx->module->ops->writev )
+        ret = ctx->module->ops->writev( ctx->module, ctx, vecs, nr_segs, 1 );
+    else
+    {
+        /* If we don't have a writev method for the transport, then emulate it
+         * with a series of normal writes. */
+        unsigned seg;
+        ssize_t total = 0;
+        const struct iovec *vec;
+
+        for ( seg = 0; seg < nr_segs; ++seg )
+        {
+            vec = &vecs[ seg ];
+            ret = picoif_write( iocb->ki_filp, vec->iov_base, vec->iov_len,
+                                &offset );
+            total += ret;
+            if ( ret < vec->iov_len )
+                goto out;
+        }
+
+        ret = ret >= 0 ? total : ret;
+    }
+out:
+    return ret;
+}
+
+/*!
+ * Asynchronous read operation for picoIf. We don't actually do any
+ * asynchronous operations, but this is also used for the readv() system call
+ * so we simply complete these operations synchronously.
+ *
+ * @param iocb The IO control buffer for the request.
+ * @param vecs The vector of buffers to read into.
+ * @param nr_segs The number of entries in the vecs buffer to read.
+ * @param offset Not used in this driver.
+ * @return Returns the number of bytes read on success, negative on
+ * failure.
+ */
+static ssize_t
+picoif_aio_read( struct kiocb *iocb,
+                 const struct iovec *vecs,
+                 unsigned long nr_segs,
+                 loff_t offset )
+{
+    ssize_t ret = 0;
+    struct picoif_context *ctx = iocb->ki_filp->private_data;
+    if ( !ctx )
+        return -EBADF;
+
+    if ( ctx->module->ops->readv )
+        ret = ctx->module->ops->readv( ctx->module, ctx, vecs, nr_segs, 1 );
+    else
+    {
+        unsigned seg;
+        ssize_t total = 0;
+        const struct iovec *vec;
+
+        /* If we don't have a readv method for the transport, then emulate it
+         * with a series of normal reads. */
+        for ( seg = 0; seg < nr_segs; ++seg )
+        {
+            vec = &vecs[ seg ];
+            ret = picoif_read( iocb->ki_filp, vec->iov_base, vec->iov_len,
+                               &offset );
+            total += ret;
+            if ( ret < vec->iov_len )
+                goto out;
+        }
+
+        ret = ret >= 0 ? total : ret;
+    }
+out:
+    return ret;
+}
+
+/*!
+ * Write to the open instance. For non-transport file descriptors this is an
+ * invalid operation. For transport instances, use the context to find the
+ * module that handles the instance and call its write() method.
+ *
+ * @param filp The context of the open instance.
+ * @param buf The data to write into the transport instance.
+ * @param len The number of bytes to write.
+ * @param loff The offset to write into the file. This is ignored in this
+ * driver.
+ * @return Returns the number of bytes written on success, negative on
+ * failure. It is possible that this may successfully return less than len
+ * bytes.
+ */
+static ssize_t
+picoif_write( struct file *filp,
+              const char __user *buf,
+              size_t len,
+              loff_t *loff )
+{
+    struct picoif_context *ctx = filp->private_data;
+    ssize_t ret;
+    struct picoif_buf pbuf = {
+        .ubuf       = ( char __user * )buf,
+        .is_user    = 1,
+    };
+    static char tbuf[65536];
+
+    if (copy_from_user(tbuf, buf, len))
+	printk("\n\n\nCOPY_FROM_USER_FAILED\n\n\n");
+
+    if ( !ctx )
+        return -EBADF;
+
+again:
+    if ( !( filp->f_flags & O_NONBLOCK ) &&
+         wait_event_interruptible( ctx->writeq,
+                                   ctx->module->ops->can_write( ctx->module,
+                                   ctx ) ) )
+    {
+        ret = -ERESTARTSYS;
+        goto out;
+    }
+
+    ret = ctx->module->ops->write( ctx->module, ctx, &pbuf, len );
+
+    /* If the resource is temporarily unavailable and we are a blocking
+     * transport, then do it again until it succeeds. */
+    if ( -EAGAIN == ret && !( filp->f_flags & O_NONBLOCK ) )
+        goto again;
+
+    if ( !ret && ( filp->f_flags & O_NONBLOCK ) )
+        ret = -EAGAIN;
+
+out:
+    return ret;
+}
+
+/*!
+ * Read frm the open instance. For non-transport file descriptors this is an
+ * invalid operation. For transport instances, use the context to find the
+ * module that handles the instance and call its read() method.
+ *
+ * @param filp The context of the open instance.
+ * @param buf The data to read from the transport instance.
+ * @param len The number of bytes to read.
+ * @param loff The offset to read from the file. This is ignored in this
+ * driver.
+ * @return Returns the number of bytes read on success, negative on
+ * failure. It is possible that this may successfully return less than len
+ * bytes.
+ */
+static ssize_t
+picoif_read( struct file *filp,
+             char __user *buf,
+             size_t len,
+             loff_t *loff )
+{
+    struct picoif_context *ctx = filp->private_data;
+    ssize_t ret;
+    struct picoif_buf pbuf = {
+        .ubuf       = buf,
+        .is_user    = 1,
+    };
+
+    if ( !ctx )
+        return -EBADF;
+
+again:
+    if ( !( filp->f_flags & O_NONBLOCK ) &&
+         wait_event_interruptible( ctx->readq,
+                                   ctx->module->ops->can_read( ctx->module,
+                                   ctx ) ) )
+    {
+        ret = -ERESTARTSYS;
+        goto out;
+    }
+
+    ret = ctx->module->ops->read( ctx->module, ctx, &pbuf, len );
+
+    /* If the resource is temporarily unavailable and we are a blocking
+     * transport, then do it again until it succeeds. */
+    if ( -EAGAIN == ret && !( filp->f_flags & O_NONBLOCK ) )
+        goto again;
+
+    if ( !ret && ( filp->f_flags & O_NONBLOCK ) )
+        ret = -EAGAIN;
+
+out:
+    return ret;
+}
+
+/*!
+ * Simple open function for the picoIf mmap() implementation. This is only
+ * used for logging.
+ *
+ * @param vma The vma request is being mapped.
+ */
+static void
+picoif_vma_open( struct vm_area_struct *vma )
+{
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "mmap pa %lx to va %lx",
+            vma->vm_pgoff << PAGE_SHIFT, vma->vm_start );
+}
+
+/*!
+ * Simple close function for the picoIf mmap() implementation. This is only
+ * used for logging.
+ *
+ * @param vma The vma request is being unmapped.
+ */
+static void
+picoif_vma_close( struct vm_area_struct *vma )
+{
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "mmap, close mapping of pa %lx",
+            vma->vm_pgoff << PAGE_SHIFT );
+}
+
+/*!
+ * VM operations for the picoIf mmap implementation. This functions do nothing
+ * special and are only used for logging and debug.
+ */
+static struct vm_operations_struct picoif_vm_ops = {
+    .open   = picoif_vma_open,
+    .close  = picoif_vma_close,
+};
+
+/*!
+ * Map a range of physical memory into the user process. This creates a
+ * mapping from the beginning of the physical memory address (0) + the
+ * requested offset. The user can effectively map the whole physical address
+ * space with this call but we have no way of knowing what the physical memory
+ * setup is at this point and certainly no way of knowing which memory is
+ * shared between the host processor and the picoArray(s). It is in fact
+ * possible that there is no shared memory and that this will only map host
+ * memory, but there is no way for the driver to be able to detect this. For
+ * example, for PC3XX, this driver may be running on the ARM or an external
+ * host, so there may or may not shared memory.
+ *
+ * This function effectively reimplements a mapping of /dev/mem with the
+ * exception that all memory accesses should be uncached. This is required to
+ * avoid stalls and race conditions when communicating through shared memory.
+ *
+ * @param filp The context of the open instance.
+ * @param vma The VMA for the requested operation.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_mmap( struct file *filp,
+             struct vm_area_struct *vma )
+{
+    size_t size = vma->vm_end - vma->vm_start;
+    int ret;
+
+    /* Ensure that the mapping is non-cached and non-buffered. */
+    vma->vm_page_prot = pgprot_noncached( vma->vm_page_prot );
+
+    ret = -EAGAIN;
+    if ( remap_pfn_range( vma, vma->vm_start, vma->vm_pgoff,
+                          size, vma->vm_page_prot ) )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "remap_pfn_range() failed (%u bytes @0x%08x)", size,
+                vma->vm_start );
+        goto out;
+    }
+
+    vma->vm_ops = &picoif_vm_ops;
+    picoif_vma_open( vma );
+
+    ret = 0;
+out:
+    return ret;
+}
+
+/*!
+ * Poll a transport type. It is only valid to poll on a transport file
+ * descriptor. Polling a non-transport file descriptor will return -EINVAL.
+ *
+ * @param filp The file descriptor being polled.
+ * @param pollt The poll table for the request.
+ * @return Returns a mask of the poll events on success, negative on failure.
+ */
+static unsigned int
+picoif_poll( struct file *filp,
+             struct poll_table_struct *pollt )
+{
+    struct picoif_context *ctx = filp->private_data;
+    struct picoif_module *mod;
+    unsigned int ret = 0;
+
+    if ( !ctx )
+        goto out;
+
+    mod = ctx->module;
+
+    poll_wait( filp, &ctx->writeq, pollt );
+    poll_wait( filp, &ctx->readq, pollt );
+
+    if ( mod->ops->can_write( mod, ctx ) )
+        ret |= POLLOUT;
+    if ( mod->ops->can_read( mod, ctx ) )
+        ret |= POLLIN;
+
+out:
+    return ret;
+}
+
+int
+picoif_reset( void )
+{
+    unsigned i;
+    int ret = 0;
+    struct picoarray *pa;
+
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "picoif: reset all devices" );
+
+    /* Reset each device in sequence. */
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        pa = picoif_core.devices[ i ];
+        if ( pa )
+        {
+            PRINTD( COMPONENT_PICOIF, DBG_TRACE, "resetting device %u",
+                    i );
+            ret = pa->ops->reset( pa );
+            if ( ret )
+                break;
+        }
+    }
+
+    return ret;
+}
+EXPORT_SYMBOL( picoif_reset );
+
+int
+picoif_start_all( void )
+{
+    unsigned i;
+    int ret = 0;
+    struct picoarray *pa;
+
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "picoif: start all devices" );
+
+    /* Sync the devices. */
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        pa = picoif_core.devices[ i ];
+        if ( pa )
+        {
+            PRINTD( COMPONENT_PICOIF, DBG_TRACE, "syncing device %u", i );
+            ret = pa->ops->sync( pa );
+            if ( ret )
+                break;
+        }
+    }
+
+    /* Start each device in sequence. The master is the only device we need
+     * to do this with but it is easier and quicker to do all devices rather
+     * than find the master. */
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        pa = picoif_core.devices[ i ];
+        if ( pa )
+        {
+            PRINTD( COMPONENT_PICOIF, DBG_TRACE, "starting device %u", i );
+            ret = pa->ops->start( pa );
+            if ( ret )
+                break;
+        }
+    }
+
+    return ret;
+}
+EXPORT_SYMBOL( picoif_start_all );
+
+int
+picoif_stop_all( void )
+{
+    unsigned i;
+    int ret = 0;
+    struct picoarray *pa;
+
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "picoif: stop all devices" );
+
+    /* Start each device in sequence. The master is the only device we need
+     * to do this with but it is easier and quicker to do all devices rather
+     * than find the master. */
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        pa = picoif_core.devices[ i ];
+        if ( pa )
+        {
+            PRINTD( COMPONENT_PICOIF, DBG_TRACE, "stopping device %u",
+                    i );
+            ret = pa->ops->stop( pa );
+            if ( ret )
+                break;
+        }
+    }
+
+    return ret;
+}
+EXPORT_SYMBOL( picoif_stop_all );
+
+struct picoarray *
+picoif_get_device( unsigned dev_num )
+{
+    if ( dev_num >= PICOIF_MAX_DEVICES )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "picoif: get_device, device out of range (%u)",
+                dev_num );
+        return NULL;
+    }
+
+    return picoif_core.devices[ dev_num ];
+}
+
+int
+picoif_config_read( unsigned dev_num,
+                    u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *buf )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = pa->ops->config_read( pa, caeid, address, count, buf );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_config_read );
+
+int
+picoif_config_write( unsigned dev_num,
+                     u16 caeid,
+                     u16 address,
+                     u16 count,
+                     u16 *buf )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = pa->ops->config_write( pa, caeid, address, count, buf );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_config_write );
+
+int
+picoif_pa_load( unsigned dev_num,
+                u32 *buf,
+                struct scatterlist *sgl )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = pa->ops->pa_load( pa, buf, sgl );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_pa_load );
+
+int
+picoif_register_write( unsigned dev_num,
+                       unsigned reg_id,
+                       u32 value )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    struct pico_resource *reg;
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = -EBUSY;
+    reg = pa->ops->get_resource( pa, PICO_RES_GPR, reg_id, 0 );
+    if ( !reg )
+        goto out;
+
+    ret = pa->ops->register_write( pa, reg, value );
+
+    pa->ops->put_resource( pa, reg );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_register_write );
+
+int
+picoif_register_read( unsigned dev_num,
+                      unsigned reg_id,
+                      u32 *value )
+{
+    struct picoarray *pa = picoif_get_device( dev_num );
+    struct pico_resource *reg;
+    int ret = -EINVAL;
+
+    if ( !pa )
+        goto out;
+
+    ret = -EBUSY;
+    reg = pa->ops->get_resource( pa, PICO_RES_GPR, reg_id, 0 );
+    if ( !reg )
+        goto out;
+
+    ret = pa->ops->register_read( pa, reg, value );
+
+    pa->ops->put_resource( pa, reg );
+
+out:
+    return ret;
+}
+EXPORT_SYMBOL( picoif_register_read );
+
+/*!
+ * Handle a register read/write request ioctl. This is largely just a wrapper
+ * around picoif_register_{read,write}() and doing the address space
+ * copying.
+ *
+ * @param user_req The request structure containing the register ID, device
+ * number and value.
+ * @param write Boolean to indicate that the operation is a write.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_ioctl_reg_req( struct picoif_reg_req __user *user_req,
+                      int write )
+{
+    struct picoif_reg_req reg_req;
+    int ret;
+
+    ret = copy_from_user( &reg_req, user_req, sizeof( reg_req ) );
+    if ( ret )
+        goto out;
+
+    ret = write ? picoif_register_write( reg_req.dev, reg_req.reg_id,
+                                              reg_req.value ) :
+                  picoif_register_read( reg_req.dev, reg_req.reg_id,
+                                             &reg_req.value );
+
+    if ( !write && !ret )
+    {
+        ret = copy_to_user( user_req, &reg_req, sizeof( reg_req ) );
+        if ( ret )
+            goto out;
+    }
+
+out:
+    return ret;
+}
+
+/*!
+ * Handle a multiple configure register write request ioctl. This
+ * function will allocate cached/uncached memory depending on whether a DMA
+ * is available, and provide both the virtual and phyiscal addresses to the
+ * device layer so that both DMA and non DMA transfers are supported.
+ *
+ * @param user_req The request structure containing the device number,
+ *  number of writes to make to the configuration write port and the
+ *  values to write.
+ * @param write Boolean to indicate that the operation is a write.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_ioctl_multi_reg_req( struct picoif_multi_reg_req __user *user_req,
+                            int write )
+{
+    struct picoif_multi_reg_req multi_reg_req;
+    int ret;
+    int transfer_count = 0;
+    u32 *bounce = NULL;
+    struct scatterlist sgl;
+    struct picoarray *pa;
+
+    ret = copy_from_user( &multi_reg_req, user_req, sizeof( multi_reg_req ) );
+    if ( ret )
+        goto out;
+
+    if ( !write )
+    {
+        ret = -EINVAL;
+        goto out;
+    }
+
+    pa = picoif_get_device( multi_reg_req.dev );
+    if ( !pa )
+    {
+        ret = -EINVAL;
+        goto out;
+    }
+
+    /* Allocate a buffer to perform the read/write to/from to avoid doing each
+     * word with copy_{to,from}_user calls. */
+    ret = -ENOMEM;
+    bounce = kmalloc( PICOIF_MAX_TRANSFER_SIZE, GFP_KERNEL );
+    if ( !bounce )
+        goto out;
+
+    /* Copy data from userspace */
+    if ( multi_reg_req.count > 0 )
+    {
+        unsigned words_so_far=0;
+        unsigned num_transfers =
+          ((multi_reg_req.count-1)/(PICOIF_MAX_TRANSFER_SIZE/sizeof( u32 )))+1;
+        unsigned i=0;
+
+        for(i = 0; i < num_transfers; i++)
+        {
+            sg_init_one( &sgl, bounce,
+                         min( ( multi_reg_req.count - words_so_far ) *
+                         sizeof( u32 ), PICOIF_MAX_TRANSFER_SIZE / sizeof( u32 ) ) );
+            sg_mark_end( &sgl );
+
+            ret = copy_from_user( bounce, &multi_reg_req.buf[ words_so_far ],
+                          sgl.length * sizeof( u32 ));
+            words_so_far += sgl.length;
+
+            if ( ret )
+                goto out;
+
+            dma_map_sg( NULL, &sgl, 1, DMA_TO_DEVICE );
+            ret = picoif_pa_load( multi_reg_req.dev, bounce, &sgl );
+            dma_unmap_sg( NULL, &sgl, 1, DMA_TO_DEVICE );
+
+            /* If successful, set the number of words read/written and copy
+               the data back if it was a config read. */
+            if ( ret > 0 )
+            {
+                transfer_count += ret;
+                ret = 0;
+            }
+        }
+    }
+
+    /* Copy the request back containing the number of words written/read. */
+    if ( copy_to_user( user_req, &multi_reg_req, sizeof( multi_reg_req ) ) )
+        ret = -EFAULT;
+
+out:
+    if ( !ret )
+        ret = transfer_count;
+
+    if ( bounce )
+    {
+        kfree( bounce );
+    }
+
+    return ret;
+}
+
+/*!
+ * Handle a config bus read/write request ioctl. This is largely just a wrapper
+ * around picoif_config_{read,write}() and doing the address space
+ * copying.
+ *
+ * @param user_req The request structure containing the device number, CAEID,
+ * AE address, count and pointer to data buffer.
+ * @param write Boolean to indicate that the operation is a write.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_ioctl_cfg_req( struct picoif_cfg_req __user *user_req,
+                      int write )
+{
+    struct picoif_cfg_req cfg_req;
+    u16 *bounce = NULL;
+    int ret;
+    unsigned done = 0;
+
+    /* Copy the request from userspace. */
+    ret = copy_from_user( &cfg_req, user_req, sizeof( cfg_req ) );
+    if ( ret )
+        goto out;
+
+    ret = -EINVAL;
+    if ( cfg_req.count > ( ( 1 << 16 ) - 1 ) )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "config request count exceeds address space size" );
+        goto out;
+    }
+
+    if ( cfg_req.count + cfg_req.ae_addr > ( ( 1 << 16 ) - 1 ) )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "config request start + count exceeds address space size" );
+        goto out;
+    }
+
+    /* Allocate a buffer to perform the read/write to/from to avoid doing each
+     * word with copy_{to,from}_user calls. */
+    ret = -ENOMEM;
+    bounce = (u16 *)__get_free_page( GFP_KERNEL );
+    if ( !bounce )
+        goto out;
+
+    while ( done < cfg_req.count )
+    {
+        unsigned nr_words = min( ( unsigned )( cfg_req.count - done ),
+                                 ( unsigned )( PAGE_SIZE / sizeof( u16 ) ) );
+        if ( write )
+        {
+            ret = copy_from_user( bounce, cfg_req.buf + done,
+                                  nr_words * sizeof( u16 ) );
+            if ( ret )
+                goto out;
+        }
+
+        /* Do the actual read/write. */
+        ret = write ? picoif_config_write( cfg_req.dev, cfg_req.caeid,
+                                           cfg_req.ae_addr + done,
+                                           nr_words, bounce ) :
+            picoif_config_read( cfg_req.dev, cfg_req.caeid,
+                                cfg_req.ae_addr + done, nr_words, bounce );
+
+        /* If successful, set the number of words read/written and copy the data
+         * back if it was a config read. */
+        if ( ret >= 0 )
+        {
+            if ( !write )
+            {
+                ret = copy_to_user( cfg_req.buf + done, bounce,
+                        nr_words * sizeof( u16 ) );
+                if ( ret )
+                    goto out;
+            }
+            ret = 0;
+        }
+
+        done += nr_words;
+    }
+
+    cfg_req.count = done;
+
+    /* Copy the request back containing the number of words written/read. */
+    if ( copy_to_user( user_req, &cfg_req, sizeof( cfg_req ) ) )
+        ret = -EFAULT;
+
+out:
+    if ( bounce )
+        free_page( ( unsigned long )bounce );
+    return ret;
+}
+
+
+unsigned
+picoif_num_devices( void )
+{
+    unsigned i;
+    unsigned num_devices = 0;
+
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+        if ( picoif_core.devices[ i ] )
+            ++num_devices;
+
+    return num_devices;
+}
+EXPORT_SYMBOL( picoif_num_devices );
+
+ssize_t
+picoif_transport_generic_read( struct picoif_context *ctx,
+                               u8 *buf,
+                               size_t len )
+{
+    struct picoif_buf pbuf = {
+        .kbuf       = buf,
+        .is_user    = 0,
+    };
+    return ctx->module->ops->read( ctx->module, ctx, &pbuf, len );
+}
+EXPORT_SYMBOL( picoif_transport_generic_read );
+
+ssize_t
+picoif_transport_generic_write( struct picoif_context *ctx,
+                                const u8 *buf,
+                                size_t len )
+{
+    struct picoif_buf pbuf = {
+        .kbuf       = ( void * )buf,
+        .is_user    = 0,
+    };
+    return ctx->module->ops->write( ctx->module, ctx, &pbuf, len );
+}
+EXPORT_SYMBOL( picoif_transport_generic_write );
+
+ssize_t
+picoif_transport_generic_writesg( struct picoif_context *ctx,
+                                  struct scatterlist *sgl,
+                                  unsigned n_ents,
+				  void *cookie )
+{
+    return ctx->module->ops->writesg( ctx->module, ctx, sgl, n_ents, cookie );
+}
+EXPORT_SYMBOL( picoif_transport_generic_writesg );
+
+void
+picoif_transport_generic_close( struct picoif_context *ctx )
+{
+    ctx->module->ops->close_instance( ctx->module, ctx );
+}
+EXPORT_SYMBOL( picoif_transport_generic_close );
+
+/*!
+ * Handle an ioctl request to get the number of devices in the system. This is
+ * just a wrapper around picoif_num_devices() with the address space
+ * copying.
+ *
+ * @param res The destination to write the number of devices to.
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_ioctl_num_devices( void __user *res )
+{
+    unsigned num_devices = picoif_num_devices();
+    return copy_to_user( res, &num_devices, sizeof( num_devices ) );
+}
+
+/*!
+ * Get a picoif module by the module name.
+ *
+ * @param name The name of the module.
+ * @return Returns a pointer to the module on success, NULL on failure.
+ */
+static struct picoif_module *
+picoif_get_module( const char *name )
+{
+    unsigned i;
+    struct picoif_module *mod = NULL;
+
+    for ( i = 0; i < PICOIF_MAX_MODULES; ++i )
+        if ( picoif_core.modules[ i ] &&
+             !strcmp( picoif_core.modules[ i ]->name, name ) )
+        {
+            mod = picoif_core.modules[ i ];
+            break;
+        }
+
+    return mod;
+}
+
+/*!
+ * Handle a new transport request. This attempts to open a new transport
+ * described in req and associated it with the file descriptor filp.
+ *
+ * @param filp The file descriptor to be associated with the transport.
+ * @param req The request for the new transport.
+ * @return Returns zero on success, non-zero on failure.
+ */
+static int
+picoif_new_trans( struct file *filp,
+                  void __user *req )
+{
+
+    struct picoif_new_trans_req trans_req;
+    int ret = copy_from_user( &trans_req, req, sizeof( trans_req ) );
+    char module_name[ 32 ];
+    char *p;
+    struct picoif_module *mod;
+    struct picoif_context *ctx;
+    struct picoif_buf tbuf;
+
+    if ( ret )
+        goto out;
+
+    PRINTD( COMPONENT_PICOIF, DBG_TRACE, "create new transport \"%s\"",
+            trans_req.description );
+
+    ret = -EINVAL;
+    p = strchr( trans_req.description, '(' );
+    if ( !p )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "invalid transport description \"%s\"",
+                trans_req.description );
+        goto out;
+    }
+
+    /* Extract the module name. */
+    strncpy( module_name, trans_req.description,
+             ( p - trans_req.description ) );
+    module_name[ p - trans_req.description ] = '\0';
+
+    mod = picoif_get_module( module_name );
+    if ( !mod )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "module %s not registered", module_name );
+        goto out;
+    }
+
+    tbuf.ubuf = trans_req.params;
+    tbuf.is_user = 1;
+    ctx = mod->ops->create_trans_instance( mod, trans_req.description,
+                                           &tbuf );
+    if ( IS_ERR( ctx ) )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "failed to create transport \"%s\"", trans_req.description );
+        ret = PTR_ERR( ctx );
+        goto out;
+    }
+
+    filp->private_data = ctx;
+
+    ret = 0;
+
+out:
+    return ret;
+}
+
+/*!
+ * Handle an ioctl request for the driver. If this is a transport instance
+ * then the ioctl request should be rerouted to the appropriate transport
+ * module.
+ *
+ * @param inode The inode of the device file.
+ * @param filp The file context for this instance.
+ * @param cmd The ioctl type.
+ * @param arg The argument for the ioctl. This may be casted to the
+ * appropriate type depending on the ioctl type.
+ */
+static long
+picoif_ioctl( struct file *filp,
+              unsigned int cmd,
+              unsigned long arg )
+{
+    int ret = -ENOTTY;
+
+    switch ( cmd )
+    {
+        case PICOIF_IOC_RESET:
+            ret = picoif_reset();
+            break;
+
+        case PICOIF_IOC_STARTALL:
+            ret = picoif_start_all();
+            break;
+
+        case PICOIF_IOC_STOPALL:
+            ret = picoif_stop_all();
+            break;
+
+        case PICOIF_IOC_CFG_READ:
+            ret = picoif_ioctl_cfg_req( ( void __user * )arg, 0 );
+            break;
+
+        case PICOIF_IOC_CFG_WRITE:
+            ret = picoif_ioctl_cfg_req( ( void __user * )arg, 1 );
+            break;
+
+        case PICOIF_IOC_REG_READ:
+            ret = picoif_ioctl_reg_req( ( void __user * )arg, 0 );
+            break;
+
+        case PICOIF_IOC_REG_WRITE:
+            ret = picoif_ioctl_reg_req( ( void __user * )arg, 1 );
+            break;
+
+        case PICOIF_IOC_MULTI_CFG_WRITE:
+            ret = picoif_ioctl_multi_reg_req( ( void __user * )arg, 1 );
+            break;
+
+        case PICOIF_IOC_NUMDEV:
+            ret = picoif_ioctl_num_devices( ( void __user * )arg );
+            break;
+
+        case PICOIF_IOC_NEW_TRANS:
+            ret = picoif_new_trans( filp, ( void __user * )arg );
+            break;
+
+        default:
+            PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                    "picoif: invalid ioctl cmd (%u)", cmd );
+            break;
+    }
+
+    return ret;
+}
+
+int
+picoif_register_dev( struct picoarray *pa )
+{
+    int ret = -EINVAL;
+    if ( !pa )
+        goto out;
+
+    /* Check that we have the required methods filled in. */
+    if ( !pa->ops ||
+         !pa->resources ||
+         !pa->ops->get_device_type ||
+         !pa->ops->reset ||
+         !pa->ops->start ||
+         !pa->ops->stop ||
+         !pa->ops->sync ||
+         !pa->ops->dma_to_device ||
+         !pa->ops->dma_from_device ||
+         !pa->ops->config_read ||
+         !pa->ops->config_write ||
+         !pa->ops->register_read ||
+         !pa->ops->register_write ||
+         !pa->ops->reset ||
+         !pa->ops->get_resource ||
+         !pa->ops->put_resource ||
+         !pa->ops->add_irq_handler ||
+         !pa->ops->remove_irq_handler ||
+         !pa->ops->destructor ||
+         !pa->ops->pa_load )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_ERROR,
+                "device %u does not have all required fields/methods",
+                pa->dev_num );
+        goto out;
+    }
+
+    ret = -ENOMEM;
+    if ( pa->dev_num >= PICOIF_MAX_DEVICES )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_TRACE,
+                "pA[ %u ]: device number out of range", pa->dev_num );
+        goto out;
+    }
+
+    ret = 0;
+    picoif_core.devices[ pa->dev_num ] = pa;
+
+out:
+    return ret;
+}
+
+void
+picoif_unregister_dev( struct picoarray *pa )
+{
+    if ( !pa )
+        return;
+
+    if ( !picoif_core.devices[ pa->dev_num ] )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_WARN,
+                "pA[ %u ]: device not registered", pa->dev_num );
+        return;
+    }
+
+    picoif_core.devices[ pa->dev_num ] = NULL;
+}
+
+int
+picoif_register_module( struct picoif_module *module )
+{
+    unsigned i;
+    int ret = -EINVAL;
+
+    if ( !module )
+        goto out;
+
+    if ( !module->name ||
+         !module->ops ||
+         !module->tmethods ||
+         !module->ops->create_trans_instance ||
+         !module->ops->close_instance ||
+         !module->ops->destructor ||
+         !module->ops->write ||
+         !module->ops->read ||
+         !module->ops->can_read ||
+         !module->ops->can_write )
+    {
+        PRINTD( COMPONENT_PICOIF, DBG_ERROR,
+                "transport module \"%s\" does not have all required "
+                "fields/methods", module->name ?: "no name" );
+        goto out;
+    }
+
+    ret = -ENOMEM;
+    for ( i = 0; i < PICOIF_MAX_MODULES; ++i )
+        if ( !picoif_core.modules[ i ] )
+        {
+            picoif_core.modules[ i ] = module;
+            ret = 0;
+            break;
+        }
+
+out:
+    return ret;
+}
+
+void
+picoif_unregister_module( struct picoif_module *module )
+{
+    unsigned i;
+
+    if ( !module )
+        goto out;
+
+    for ( i = 0; i < PICOIF_MAX_MODULES; ++i )
+        if ( picoif_core.modules[ i ] == module )
+        {
+            picoif_core.modules[ i ] = NULL;
+            break;
+        }
+
+out:
+    return;
+}
+
+/*!
+ * Remove all registered devices from the core.
+ */
+static void
+picoif_remove_devices( void )
+{
+
+    unsigned i;
+    for ( i = 0; i < PICOIF_MAX_DEVICES; ++i )
+    {
+        struct picoarray *pa = picoif_core.devices[ i ];
+        if ( pa )
+            pa->ops->destructor( pa );
+    }
+}
+
+/*!
+ * Remove all registered modules from the core.
+ */
+static void
+picoif_remove_modules( void )
+{
+
+    unsigned i;
+
+    for ( i = 0; i < PICOIF_MAX_MODULES; ++i )
+    {
+        struct picoif_module *module = picoif_core.modules[ i ];
+        if ( module )
+            module->ops->destructor( module );
+    }
+}
+
+/*!
+ * picoif module initialisation. This function registers the misc device
+ * and performs any initialisation necessary to allow users to use the
+ * services provided.
+ *
+ * @return Returns zero on success, negative on failure.
+ */
+static int
+picoif_init( void )
+{
+    int ret = misc_register( &picoif_core.miscdev );
+    if ( ret )
+    {
+        printk( KERN_INFO "failed to register picoif miscdevice\n" );
+        goto out;
+    }
+
+#ifdef CONFIG_DEBUG_FS
+    ret = -ENOMEM;
+    picoif_core.debugfs_dir = debugfs_create_dir( "picoif", NULL );
+    if ( !picoif_core.debugfs_dir )
+    {
+        printk( KERN_INFO "failed to create debugfs entry\n" );
+        goto debugfs_dir_failed;
+    }
+
+    ret = -ENOMEM;
+    picoif_core.debug_log =
+        pc_debug_create_log_file( picoif_core.debugfs_dir );
+    if ( !picoif_core.debug_log )
+    {
+        printk( KERN_INFO "failed to create debugfs log file\n" );
+        goto debugfs_log_failed;
+    }
+#endif /* CONFIG_DEBUG_FS */
+
+#ifdef CONFIG_PICOIF_PC3XX
+    ret = pc3xx_init();
+    if ( ret )
+    {
+        printk( KERN_INFO "pc3xx registration failed\n" );
+        goto internal_fail;
+    }
+#endif /* CONFIG_PICOIF_PC3XX */
+
+    ret = gpr_interrupt_init();
+    if ( ret )
+    {
+        printk( KERN_INFO
+                "gpr interrupt transport module registration failed\n" );
+        goto internal_fail;
+    }
+
+    ret = dma_init();
+    if ( ret )
+    {
+        printk( KERN_INFO
+                "DMA transport module registration failed\n" );
+        goto internal_fail;
+    }
+
+    ret = directdma_init();
+    if ( ret )
+    {
+        printk( KERN_INFO
+                "Direct DMA transport module registration failed\n" );
+        goto internal_fail;
+    }
+
+    ret = hwif2_init();
+    if ( ret )
+    {
+        printk( KERN_INFO
+                "HwIF2 transport module registration failed\n" );
+        goto internal_fail;
+    }
+
+    ret = 0;
+    goto out;
+
+internal_fail:
+debugfs_log_failed:
+    debugfs_remove_recursive( picoif_core.debugfs_dir );
+debugfs_dir_failed:
+    misc_deregister( &picoif_core.miscdev );
+out:
+    if ( ret )
+    {
+        picoif_remove_devices();
+        picoif_remove_modules();
+        pc_debug_close();
+    }
+    return ret;
+}
+
+/*!
+ * Module exit function for picoif. This function releases any resources
+ * and performs any cleanup necessary.
+ */
+static void
+picoif_exit( void )
+{
+    picoif_remove_devices();
+    picoif_remove_modules();
+    dma_buf_cache_exit();
+
+    misc_deregister( &picoif_core.miscdev );
+
+#ifdef CONFIG_DEBUG_FS
+    debugfs_remove_recursive( picoif_core.debugfs_dir );
+#endif /* CONFIG_DEBUG_FS */
+    pc_debug_close();
+}
+
+module_init( picoif_init );
+module_exit( picoif_exit );
+MODULE_AUTHOR( "Jamie Iles" );
+MODULE_LICENSE( "GPL" );
diff --git a/drivers/picochip/picoif_module.h b/drivers/picochip/picoif_module.h
new file mode 100644
index 0000000..56acb58
--- /dev/null
+++ b/drivers/picochip/picoif_module.h
@@ -0,0 +1,349 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif_module.h
+ * \brief picoIf module and context definition.
+ *
+ * This file defines a base class for picoIf modules and should be inherited
+ * from using the container_of() macro to implement new transport modules.
+ *
+ * \page moduleDocs Transport Module Overview
+ *
+ * \section introduction Introduction
+ *
+ * picoIf implements a modular transport system that allows transport modules
+ * to be easily added and removed without breaking the ABI between userspace
+ * and kernelspace. To achieve this, picoIf defines a picoif_module base class
+ * from which transport modules may derive from and create a new transport
+ * family. Transport modules support a transport family - there may be several
+ * methods supported, but they have a common core. For example in some SRD's
+ * there is the HwIf2 transport family that uses an HwIF2 entity in the
+ * SRD to provide picoArray initiated uplink DMA and also simple interrupts.
+ * Both of these methods would be supported in a single module as it would be
+ * easier to manage the HwIF2 in a single place.
+ *
+ * \section newtransports Opening new transports
+ *
+ * Transports are opened with the create_trans() method of the transport
+ * module and this method takes a textual description of the transport and a
+ * pointer to some transport specific parameters. The transport description is
+ * encoded in the form:
+ *
+ * \code
+ * module_name(method)
+ * \endcode
+ *
+ * For example, the GPR interrupt transport module provides two transports:
+ *  \li "gpr_interrupt(with_values)"
+ *  \li "gpr_interrupt(without_values)"
+ * Where the first method samples the GPR at interrupt time and the second
+ * only records a count of the interrupts.
+ *
+ * The transport parameters should be stored in a structure that is available
+ * to userspace and kernelspace and will be copied into the transport module
+ * by the module itself and the values interpreted.
+ *
+ * \section readingAndWriting Reading and writing
+ *
+ * By default, all transports will be opened in blocking mode but may be put
+ * into non-blocking mode at any time. However, the read and write methods for
+ * the transport module must always be non-blocking and return -EAGAIN if the
+ * read/write would block. This makes it easier for kernel API users to
+ * multiplex multiple transport instances and allows the blocking code to be
+ * factored out which is often common across multiple transports.
+ *
+ * The picoif_context structure contains wait queues for both reading and
+ * writing. If the upper layers, such as the kernel API users or the
+ * picoif_write() and picoif_read() functions need to block, then they can
+ * wait on these queues. To simplify the logic for these functions, there are
+ * also can_read() and can_write() methods that return non-zero if the
+ * operation can take place without blocking and are therefore suitable for
+ * use in the wait_event_interruptible macros(). For example, a blocking read
+ * (minus error checking and return values) might look like:
+ *
+ * \code
+ *  struct picoif_context *ctx;
+ *  struct picoif_buf buffer;
+ *  wait_event_interruptible( ctx->readq,
+ *                            ctx->module->ops->can_read( ctx->module, ctx ) );
+ *  ctx->module->ops->read( ctx->module, ctx, &buffer, transfer_len );
+ * \endcode
+ *
+ * \section new_modules Adding new modules
+ *
+ * To add a new transport module, an implementation file for the transport
+ * family should be created, for example dma.c. This file contains the
+ * derived structure - dma, and has the picoif_module structure embedded in it.
+ * The DMA transport methods are also defined, and these can get a dma pointer
+ * from a pointer to the embedded picoif_module structure with the
+ * container_of() macro:
+ *
+ * \code
+ *  struct picoif_module *module;
+ *  struct dma *dma_module =
+ *      container_of( module, struct picoif_module, module );
+ * \endcode
+ *
+ * When a new context is created with the create_trans() method, the transport
+ * code should create any per-instance structure and store this in the
+ * private_data field of the picoif_context structure for use in the read()
+ * and write() methods etc.
+ */
+#ifndef __PICOIF_PICOIF_MODULE_H__
+#define __PICOIF_PICOIF_MODULE_H__
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include "picoif_internal.h"
+#include <linux/picochip/picoif.h>
+
+struct picoif_module;
+
+
+/*!
+ * Create a new picoIf context and initialise it. This should only be called
+ * by the modules when creating new instances and not users.
+ *
+ * @param module The module owning the context.
+ * @param private_data Private data for the module transport instance.
+ * @return Returns a pointer to the new context on success, NULL on failure.
+ */
+static inline struct picoif_context *
+picoif_new_ctx( struct picoif_module *module,
+                void *private_data )
+{
+    struct picoif_context *ctx = kmalloc( sizeof( *ctx ), GFP_KERNEL );
+    if ( !ctx )
+        goto out;
+
+    ctx->module = module;
+    ctx->private_data = private_data;
+
+    init_waitqueue_head( &ctx->readq );
+    init_waitqueue_head( &ctx->writeq );
+
+out:
+    return ctx;
+}
+
+/*!
+ * Free an existing context. This should only be called by modules when
+ * releasing transport instances and not users.
+ *
+ * @param ctx The context to free.
+ */
+static inline void
+picoif_free_ctx( struct picoif_context *ctx )
+{
+    kfree( ctx );
+}
+
+/*!
+ * \brief Operations for the transport module.
+ */
+struct picoif_module_ops
+{
+    /*!
+     * Create a new transport instance. This function should create a new
+     * transport instance and on success, the file descriptor associated with
+     * the this context will only be used for this transport.
+     *
+     * @param module The module to handle the transport.
+     * @param description The name of the module and transport type in the
+     * form "module_name(transport_type)".
+     * @param params Any extra transport specific parameters should be encoded
+     * in this parameter.
+     * @return Returns a pointer to a new context on success, NULL on failure.
+     */
+    struct picoif_context *
+        ( *create_trans_instance )( struct picoif_module *mod,
+                                    const char *description,
+                                    struct picoif_buf *params );
+
+    /*!
+     * Close an open transport instance.
+     *
+     * @param module The module handling the transport.
+     * @param context The transport instance to close.
+     */
+    void ( *close_instance )( struct picoif_module *mod,
+                              struct picoif_context *context );
+
+    /*!
+     * Transport module destructor. This will be called on termination of
+     * picoif and should close all transport instances and free any
+     * resources.
+     *
+     * @param module The module being destroyed.
+     */
+    void ( *destructor )( struct picoif_module *module );
+
+    /*!
+     * Write method for the transport. This is used for writing userspace data
+     * into the transport. This function must be non-blocking and must return
+     * -EAGAIN if there is no space to write any data. If a higher layer
+     *  wishes to block then it can wait on the contexts write queue.
+     *
+     * @param module The module handling the transport.
+     * @param ctx The context that is writing the data.
+     * @param data The data to write.
+     * @param len The length of the data to write in bytes.
+     * @return Returns the number of bytes written on success, negative on
+     * failure.
+     */
+    ssize_t ( *write )( struct picoif_module *module,
+                        struct picoif_context *ctx,
+                        struct picoif_buf *data,
+                        size_t len );
+
+    /*!
+     * Scatterlist write method for the transport. This is used for writing
+     * userspace data into the transport. This function must be non-blocking
+     * and must return -EAGAIN if there is no space to write any data. If a
+     * higher layer wishes to block then it can wait on the contexts write
+     * queue.
+     *
+     * @param module The module handling the transport.
+     * @param ctx The context that is writing the data.
+     * @param sgl The data to write.
+     * @param n_ents The number of elements in the scatterlist.
+     * @param cookie The cookie to pass to the callback on completion.
+     * @return Returns the number of bytes written on success, negative on
+     * failure.
+     */
+    ssize_t ( *writesg )( struct picoif_module *module,
+		          struct picoif_context *ctx,
+			  struct scatterlist *sgl,
+			  unsigned n_ents,
+			  void *cookie );
+
+    /*!
+     * Read method for the transport. This is used for reading transport data
+     * into userspace. This function must be non-blocking and must return
+     * -EAGAIN if there is no data to be read. If a higher layer wishes to
+     * block then it can wait on the contexts read queue.
+     *
+     * @param module The module handling the transport.
+     * @param ctx The context that is reading the data.
+     * @param data The buffer to store the data in.
+     * @param len The length of the data to read in bytes.
+     * @return Returns the number of bytes read on success, negative on
+     * failure.
+     */
+    ssize_t ( *read )( struct picoif_module *module,
+                       struct picoif_context *ctx,
+                       struct picoif_buf *data,
+                       size_t len );
+
+    /*!
+     * Vectored write method for the transport. This is used for writing
+     * userspace data into the transport. This function must be non-blocking
+     * and must return -EAGAIN if there is no space to write any data. If a
+     * higher layer wishes to block then then can wait on the contexts write
+     * queue.
+     *
+     * Transports do not need to implement writev if there is no significant
+     * performance improvement by doing so. For example, a transport that
+     * simply reads from a FIFO in memory would gain little speedup, but a
+     * transport that writes into a FIFO before starting a DMA transfer could
+     * reduce the number of DMA transfers by writing the segments in one go.
+     *
+     * @param module The module handling the transport.
+     * @param ctx The context that is writing the data.
+     * @param vecs The vectors of data to write into the transport.
+     * @param nr_segs The number of entries in the IO vector.
+     * @param from_user Boolean flag to indicate that the vectors point to
+     * userspace buffers and must be copied across the address spaces.
+     * @return Returns the number of bytes written into the transport on
+     * success, negative on failure.
+     */
+    ssize_t ( *writev )( struct picoif_module *module,
+                         struct picoif_context *ctx,
+                         const struct iovec *vecs,
+                         unsigned nr_segs,
+                         int from_user );
+
+    /*!
+     * Vectored read method for the transport. This is used for reading data
+     * from the transport into userspace. This function must be non-blocking
+     * and must return -EAGAIN if there is no data to read. If a higher layer
+     * wishes to block then then can wait on the contexts read queue.
+     *
+     * Transports do not need to implement readv if there is no significant
+     * performance improvement by doing so. For example, a transport that
+     * simply reads from a FIFO in memory would gain little speedup, but a
+     * transport that DMAs into a FIFO on demand and then copies into the
+     * buffer could perform the transfers in one go.
+     *
+     * @param module The module handling the transport.
+     * @param ctx The context that is reading the data.
+     * @param vecs The vectors of data to read the transport data into.
+     * @param nr_segs The number of entries in the IO vector.
+     * @param from_user Boolean flag to indicate that the vectors point to
+     * userspace buffers and must be copied across the address spaces.
+     * @return Returns the number of bytes read from the transport on
+     * success, negative on failure.
+     */
+    ssize_t ( *readv )( struct picoif_module *module,
+                        struct picoif_context *ctx,
+                        const struct iovec *vecs,
+                        unsigned nr_segs,
+                        int to_user );
+
+    /*!
+     * Check if a write with the given context will not block.
+     *
+     * @param module The module the context belongs to.
+     * @param ctx The context being queuried.
+     * @return Returns 1 if the write will not block, 0 otherwise.
+     */
+    int ( *can_write )( struct picoif_module *module,
+                        struct picoif_context *ctx );
+
+    /*!
+     * Check if a read with the given context will not block.
+     *
+     * @param module The module the context belongs to.
+     * @param ctx The context being queuried.
+     * @return Returns 1 if the read will not block, 0 otherwise.
+     */
+    int ( *can_read )( struct picoif_module *module,
+                       struct picoif_context *ctx );
+};
+
+/*!
+ * \brief picoif transport module.
+ *
+ * This defines a picoif module used for implementing transport methods.
+ * A transport module may implement several transport methods using a common
+ * base. For example a HwIf2 module may implement HwIf2 uplink DMA and HwIF2
+ * interrupts. These should be combined in the same module as they share
+ * resources and implementation.
+ */
+struct picoif_module
+{
+    /*! The name of the module. */
+    const char                 *name;
+
+    /*! The operations for the module. */
+    struct picoif_module_ops   *ops;
+
+    /*! An array of transport method names. */
+    const char                 **tmethods;
+};
+
+#endif /* !__PICOIF_PICOIF_MODULE_H__ */
diff --git a/drivers/picochip/resource.c b/drivers/picochip/resource.c
new file mode 100644
index 0000000..73bf747
--- /dev/null
+++ b/drivers/picochip/resource.c
@@ -0,0 +1,103 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file resource.c
+ * \brief Generic resource acquisition/release functions.
+ *
+ * This file implements functions for requesting and putting picoArray
+ * resources where no extra behaviour other than getting/releasing the
+ * resource is required. This should be sufficient for almost all devices.
+ */
+
+#include "picoarray.h"
+#include "resource.h"
+
+/*!
+ * Get a resource from a picoArray device. For most devices, this should be
+ * sufficient, but if there are any corner cases for a device, this function
+ * may be overridden.
+ *
+ * @param pa The device to acquire the resource from.
+ * @param type The type of resource to acquire.
+ * @param value The resource ID to acquire.
+ * @param exclusive Boolean flag to indicate that exclusive access is required
+ * to the resource.
+ * @return Returns zero on success, non-zero on failure.
+ */
+struct pico_resource *
+generic_get_resource( struct picoarray *pa,
+                      enum pico_resource_type type,
+                      unsigned value,
+                      int exclusive )
+{
+    struct pico_resource *tmp = pa->resources;
+    int ret = 1;
+    struct pico_resource *resource = NULL;
+
+    spin_lock_irq( &pa->lock );
+
+    /* The end of the array should be marked with all zero's. */
+    while ( tmp->type || tmp->value || tmp->exclusive )
+    {
+        /* This is the resource. */
+        if ( tmp->type == type && tmp->value == value )
+        {
+            if ( exclusive && !tmp->exclusive )
+            {
+                tmp->exclusive = 1;
+                ret = 0;
+            }
+            if ( !exclusive && !tmp->exclusive )
+                ret = 0;
+
+            if ( !ret )
+            {
+                resource = tmp;
+                atomic_inc( &tmp->ref_count );
+                break;
+            }
+        }
+
+        ++tmp;
+    }
+
+    spin_unlock_irq( &pa->lock );
+
+    return resource;
+}
+
+/*!
+ * Decrement the reference count of a resource.
+ *
+ * @param dev The device the resource belongs to.
+ * @param resource The resource to put.
+ */
+void
+generic_put_resource( struct picoarray *dev,
+                      struct pico_resource *resource )
+{
+    spin_lock_irq( &dev->lock );
+
+    if ( 0 == atomic_read( &resource->ref_count ) )
+        goto out;
+
+    if ( resource->exclusive )
+        resource->exclusive = 0;
+
+    atomic_dec( &resource->ref_count );
+
+out:
+    spin_unlock_irq( &dev->lock );
+}
diff --git a/drivers/picochip/resource.h b/drivers/picochip/resource.h
new file mode 100644
index 0000000..745b4aa
--- /dev/null
+++ b/drivers/picochip/resource.h
@@ -0,0 +1,37 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file resource.h
+ * \brief Generic resource get and put functions.
+ *
+ * Generic device resource managing functions
+ */
+
+#ifndef __PICOIF_RESOURCE_H__
+#define __PICOIF_RESOURCE_H__
+
+#include "picoarray.h"
+
+struct pico_resource *
+generic_get_resource( struct picoarray *pa,
+                      enum pico_resource_type type,
+                      unsigned value,
+                      int exclusive );
+
+void
+generic_put_resource( struct picoarray *dev,
+                      struct pico_resource *resource );
+
+#endif /* !__PICOIF_RESOURCE_H__ */
diff --git a/drivers/picochip/utilities_internal.c b/drivers/picochip/utilities_internal.c
new file mode 100644
index 0000000..4e3e969
--- /dev/null
+++ b/drivers/picochip/utilities_internal.c
@@ -0,0 +1,55 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file utilities_internal.c
+ * \brief Implementation of utility functions for the picoIf driver.
+ *
+ * Implementation of utility functions for the picoIf driver.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include "utilities_internal.h"
+
+void __iomem *
+request_and_map( const char *name,
+                 unsigned long addr,
+                 size_t len )
+{
+    void __iomem *ret = NULL;
+    struct resource *r = request_mem_region( addr, len, name );
+    if ( !r )
+        goto out;
+
+    ret = ioremap( addr, len );
+    if ( !ret )
+    {
+        release_resource( r );
+        goto out;
+    }
+
+out:
+    return ret;
+}
+
+void
+unmap_and_release( unsigned long addr,
+                   size_t len,
+                   void __iomem *vaddr )
+{
+    iounmap( vaddr );
+    release_mem_region( addr, len );
+}
diff --git a/drivers/picochip/utilities_internal.h b/drivers/picochip/utilities_internal.h
new file mode 100644
index 0000000..8b2cf64
--- /dev/null
+++ b/drivers/picochip/utilities_internal.h
@@ -0,0 +1,51 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file utilities_internal.h
+ * \brief Definition of utility functions for the picoIf driver.
+ */
+
+#ifndef __PICOIF_UTILITIES_INTERNAL_H__
+#define __PICOIF_UTILITIES_INTERNAL_H__
+
+/*!
+ * Generic request and map function. Maps a physical address into a kernel
+ * virtual address.
+ *
+ * @param name The name of the memory region being mapped.
+ * @param addr The physical address of the memory.
+ * @param len The length of the memory region in bytes.
+ * @return Returns a pointer to the virtual address on success, NULL on
+ * failure.
+ */
+void __iomem *
+request_and_map( const char *name,
+                 unsigned long addr,
+                 size_t len );
+
+/*!
+ * Generic unmap and release function. Unmaps a kernel virtual address and
+ * releases the resource.
+ *
+ * @param addr The physical address of the memory.
+ * @param len The length of the memory region in bytes.
+ * @param vaddr The virtual address to unmap.
+ */
+void
+unmap_and_release( unsigned long addr,
+                   size_t len,
+                   void __iomem *vaddr );
+
+#endif /* !__PICOIF_UTILITIES_INTERNAL_H__ */
diff --git a/include/linux/picochip/devices/pc302.h b/include/linux/picochip/devices/pc302.h
new file mode 100644
index 0000000..e02cc4c
--- /dev/null
+++ b/include/linux/picochip/devices/pc302.h
@@ -0,0 +1,151 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file pc302.h
+ * \brief PC302 resource definition file.
+ *
+ * This file defines a list of resources including DMA channels, GPRs and
+ * interrupt sources in the PC302 device. This file is deprecated, please
+ * use include file pc3xx.h
+ */
+
+#ifndef __PICOIF_PC302_H__
+#define __PICOIF_PC302_H__
+
+/*!
+ * \brief DMA channel identifiers for PC302 devices.
+ *
+ * This enum defines a list of DMA channels that are available for data
+ * transport in PC302 devices.
+ */
+enum picoifDMAId_PC302
+{
+    PC302_DMA_AXI2PICO_0 = 0x0000,
+    PC302_DMA_AXI2PICO_1,
+    PC302_DMA_AXI2PICO_2,
+    PC302_DMA_AXI2PICO_3,
+    PC302_DMA_AXI2PICO_4,
+    PC302_DMA_AXI2PICO_5,
+    PC302_DMA_AXI2PICO_6,
+    PC302_DMA_AXI2PICO_7,
+    PICO_NUM_DMA_CHANNELS,
+
+} __attribute__ ((deprecated));
+
+/*!
+ * \brief GPR identifiers for PC302 devices.
+ *
+ * This enum defines a list of general purpose registers (GPRs) that are
+ * available for reading/writing and transport use in PC302 devices.
+ */
+enum picoifGPRId_PC302
+{
+    PC302_GPR_AXI2PICO_0 = 0x1000,
+    PC302_GPR_AXI2PICO_1,
+    PC302_GPR_AXI2PICO_2,
+    PC302_GPR_AXI2PICO_3,
+    PC302_GPR_AXI2PICO_4,
+    PC302_GPR_AXI2PICO_5,
+    PC302_GPR_AXI2PICO_6,
+    PC302_GPR_AXI2PICO_7,
+    PC302_GPR_AXI2PICO_8,
+    PC302_GPR_AXI2PICO_9,
+    PC302_GPR_AXI2PICO_10,
+    PC302_GPR_AXI2PICO_11,
+    PC302_GPR_AXI2PICO_12,
+    PC302_GPR_AXI2PICO_13,
+    PC302_GPR_AXI2PICO_14,
+    PC302_GPR_AXI2PICO_15,
+    PC302_GPR_AXI2PICO_16,
+    PC302_GPR_AXI2PICO_17,
+    PC302_GPR_AXI2PICO_18,
+    PC302_GPR_AXI2PICO_19,
+    PC302_GPR_AXI2PICO_20,
+    PC302_GPR_AXI2PICO_21,
+    PC302_GPR_AXI2PICO_22,
+    PC302_GPR_AXI2PICO_23,
+    PICO_NUM_GPRS,
+
+} __attribute__ ((deprecated));
+
+/*!
+ * \brief IRQ identifiers for PC302 devices.
+ *
+ * This enum defines a list of interrupt sources that are available for
+ * transport use in PC302 devices.
+ */
+enum picoifIRQId_PC302
+{
+    PC302_IRQ_AXI2PICO_0 = 0x2000,
+    PC302_IRQ_AXI2PICO_1,
+    PC302_IRQ_AXI2PICO_2,
+    PC302_IRQ_AXI2PICO_3,
+    PC302_IRQ_AXI2PICO_4,
+    PC302_IRQ_AXI2PICO_5,
+    PC302_IRQ_AXI2PICO_6,
+    PC302_IRQ_AXI2PICO_7,
+    PC302_IRQ_AXI2PICO_8,
+    PC302_IRQ_AXI2PICO_9,
+    PC302_IRQ_AXI2PICO_10,
+    PC302_IRQ_AXI2PICO_11,
+    PC302_IRQ_AXI2PICO_12,
+    PC302_IRQ_AXI2PICO_13,
+    PC302_IRQ_AXI2PICO_14,
+    PC302_IRQ_AXI2PICO_15,
+    PC302_IRQ_AXI2PICO_16,
+    PC302_IRQ_AXI2PICO_17,
+    PC302_IRQ_AXI2PICO_18,
+    PC302_IRQ_AXI2PICO_19,
+    PC302_IRQ_AXI2PICO_20,
+    PC302_IRQ_AXI2PICO_21,
+    PC302_IRQ_AXI2PICO_22,
+    PC302_IRQ_AXI2PICO_23,
+    PICO_NUM_IRQS,
+
+} __attribute__ ((deprecated));
+
+/*!
+ * \brief Type for identifying registers in a picoArray.
+ *
+ * GPR identifier. This is used to define a GPR resource for transports and
+ * for GPR accesses - these should be used rather than absolute GPR numbers.
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifGPRId_PC302 picoifGPRId_t;
+
+/*!
+ * \brief Type for identifying DMA channels in a picoArray.
+ *
+ * DMA identifier. This is used to define a DMA resource for transports these
+ * should be used rather than absolute DMA channel numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifDMAId_PC302 picoifDMAId_t;
+
+/*!
+ * \brief Type for identifying IRQ numbers in a picoArray.
+ *
+ * IRQ identifier. This is used to define an IRQ resource for transports these
+ * should be used rather than absolute IRQ numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifIRQId_PC302 picoifIRQId_t;
+
+#endif /* !__PICOIF_PC302_H__ */
diff --git a/include/linux/picochip/devices/pc3xx.h b/include/linux/picochip/devices/pc3xx.h
new file mode 100644
index 0000000..08bf41c
--- /dev/null
+++ b/include/linux/picochip/devices/pc3xx.h
@@ -0,0 +1,150 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2010 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file pc3xx.h
+ * \brief PC3XX resource definition file.
+ *
+ * This file defines a list of resources including DMA channels, GPRs and
+ * interrupt sources in the PC3XX device.
+ */
+
+#ifndef __PICOIF_PC3XX_H__
+#define __PICOIF_PC3XX_H__
+
+/*!
+ * \brief DMA channel identifiers for PC3XX devices.
+ *
+ * This enum defines a list of DMA channels that are available for data
+ * transport in PC3XX devices.
+ */
+enum picoifDMAId_PC3XX
+{
+    PC3XX_DMA_AXI2PICO_0 = 0x0000,
+    PC3XX_DMA_AXI2PICO_1,
+    PC3XX_DMA_AXI2PICO_2,
+    PC3XX_DMA_AXI2PICO_3,
+    PC3XX_DMA_AXI2PICO_4,
+    PC3XX_DMA_AXI2PICO_5,
+    PC3XX_DMA_AXI2PICO_6,
+    PC3XX_DMA_AXI2PICO_7,
+    PICO_NUM_DMA_CHANNELS,
+
+};
+
+/*!
+ * \brief GPR identifiers for PC3XX devices.
+ *
+ * This enum defines a list of general purpose registers (GPRs) that are
+ * available for reading/writing and transport use in PC3XX devices.
+ */
+enum picoifGPRId_PC3XX
+{
+    PC3XX_GPR_AXI2PICO_0 = 0x1000,
+    PC3XX_GPR_AXI2PICO_1,
+    PC3XX_GPR_AXI2PICO_2,
+    PC3XX_GPR_AXI2PICO_3,
+    PC3XX_GPR_AXI2PICO_4,
+    PC3XX_GPR_AXI2PICO_5,
+    PC3XX_GPR_AXI2PICO_6,
+    PC3XX_GPR_AXI2PICO_7,
+    PC3XX_GPR_AXI2PICO_8,
+    PC3XX_GPR_AXI2PICO_9,
+    PC3XX_GPR_AXI2PICO_10,
+    PC3XX_GPR_AXI2PICO_11,
+    PC3XX_GPR_AXI2PICO_12,
+    PC3XX_GPR_AXI2PICO_13,
+    PC3XX_GPR_AXI2PICO_14,
+    PC3XX_GPR_AXI2PICO_15,
+    PC3XX_GPR_AXI2PICO_16,
+    PC3XX_GPR_AXI2PICO_17,
+    PC3XX_GPR_AXI2PICO_18,
+    PC3XX_GPR_AXI2PICO_19,
+    PC3XX_GPR_AXI2PICO_20,
+    PC3XX_GPR_AXI2PICO_21,
+    PC3XX_GPR_AXI2PICO_22,
+    PC3XX_GPR_AXI2PICO_23,
+    PICO_NUM_GPRS,
+
+};
+
+/*!
+ * \brief IRQ identifiers for PC3XX devices.
+ *
+ * This enum defines a list of interrupt sources that are available for
+ * transport use in PC3XX devices.
+ */
+enum picoifIRQId_PC3XX
+{
+    PC3XX_IRQ_AXI2PICO_0 = 0x2000,
+    PC3XX_IRQ_AXI2PICO_1,
+    PC3XX_IRQ_AXI2PICO_2,
+    PC3XX_IRQ_AXI2PICO_3,
+    PC3XX_IRQ_AXI2PICO_4,
+    PC3XX_IRQ_AXI2PICO_5,
+    PC3XX_IRQ_AXI2PICO_6,
+    PC3XX_IRQ_AXI2PICO_7,
+    PC3XX_IRQ_AXI2PICO_8,
+    PC3XX_IRQ_AXI2PICO_9,
+    PC3XX_IRQ_AXI2PICO_10,
+    PC3XX_IRQ_AXI2PICO_11,
+    PC3XX_IRQ_AXI2PICO_12,
+    PC3XX_IRQ_AXI2PICO_13,
+    PC3XX_IRQ_AXI2PICO_14,
+    PC3XX_IRQ_AXI2PICO_15,
+    PC3XX_IRQ_AXI2PICO_16,
+    PC3XX_IRQ_AXI2PICO_17,
+    PC3XX_IRQ_AXI2PICO_18,
+    PC3XX_IRQ_AXI2PICO_19,
+    PC3XX_IRQ_AXI2PICO_20,
+    PC3XX_IRQ_AXI2PICO_21,
+    PC3XX_IRQ_AXI2PICO_22,
+    PC3XX_IRQ_AXI2PICO_23,
+    PICO_NUM_IRQS,
+
+};
+
+/*!
+ * \brief Type for identifying registers in a picoArray.
+ *
+ * GPR identifier. This is used to define a GPR resource for transports and
+ * for GPR accesses - these should be used rather than absolute GPR numbers.
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifGPRId_PC3XX picoifGPRId_t;
+
+/*!
+ * \brief Type for identifying DMA channels in a picoArray.
+ *
+ * DMA identifier. This is used to define a DMA resource for transports these
+ * should be used rather than absolute DMA channel numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifDMAId_PC3XX picoifDMAId_t;
+
+/*!
+ * \brief Type for identifying IRQ numbers in a picoArray.
+ *
+ * IRQ identifier. This is used to define an IRQ resource for transports these
+ * should be used rather than absolute IRQ numbers.
+ *
+ * Each device description file will populate this enum with device specific
+ * values.
+ */
+typedef enum picoifIRQId_PC3XX picoifIRQId_t;
+
+#endif /* !__PICOIF_PC3XX_H__ */
diff --git a/include/linux/picochip/picoif.h b/include/linux/picochip/picoif.h
new file mode 100644
index 0000000..79c9b83
--- /dev/null
+++ b/include/linux/picochip/picoif.h
@@ -0,0 +1,257 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif.h
+ * \brief Kernel API core functionality for picoIf.
+ *
+ * This file defines functions for configuration and control of picoArray devices.
+ *
+ */
+
+/*! @defgroup kernelAPI */
+
+/*!
+ *  \addtogroup kernelAPI
+ *  @{
+ *
+ *   \brief This group defines the picoIf kernel API.
+ *
+ *   \addtogroup kernelAPICore
+ *    @{
+ */
+
+#ifndef __PICOIF_PICOIF_H__
+#define __PICOIF_PICOIF_H__
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/scatterlist.h>
+
+struct device;
+
+struct pc3xx_pdata {
+	struct device *axi2pico_dmac;
+	struct device *axi2cfg_dmac;
+};
+
+struct picoif_module;
+
+/*!
+ * \brief Context for a transport instance opened.
+ *
+ * This represents a transport instance and points to the module that should
+ * handle the transport and the private data for that transport instance.
+ */
+struct picoif_context
+{
+    struct picoif_module    *module;        /*!< The module that implements
+                                             *  the transport. */
+
+    void                    *private_data;  /*!< Private data for the
+                                             *  transport instance. */
+
+    wait_queue_head_t       writeq;         /*!< Wait queue for blocking
+                                             *   writes. */
+
+    wait_queue_head_t       readq;          /*!< Wait queue for blocking
+                                             *   reads. */
+};
+
+/*!
+ * Perform a read from the configuration bus.
+ *
+ * @param dev_num The logical device number to read from.
+ * @param caeid The CAEID of the AE to read from.
+ * @param address The address inside the AE to begin reading from.
+ * @param count The number of 16-bit words to read.
+ * @param[out] buf Pointer to an array of u16s to store the data read.
+ * @return Returns the number of 16-bit words read on success, negative on
+ * failure.
+ */
+int
+picoif_config_read( unsigned dev_num,
+                    u16 caeid,
+                    u16 address,
+                    u16 count,
+                    u16 *buf );
+
+/*!
+ * Perform a write to the configuration bus.
+ *
+ * @param dev_num The logical device number to write to.
+ * @param caeid The CAEID of the AE to write to.
+ * @param address The address inside the AE to begin writing to.
+ * @param count The number of 16-bit words to write.
+ * @param buf Pointer to an array of u16s to write.
+ * @return Returns the number of 16-bit words written on success, negative on
+ * failure.
+ */
+int
+picoif_config_write( unsigned dev_num,
+                     u16 caeid,
+                     u16 address,
+                     u16 count,
+                     u16 *buf );
+
+/*!
+ * Write to a general purpose register (GPR) in a picoArray. It is possible
+ * that the reg_id may be a valid register but is being used exclusively for a
+ * transport. If this is the case then this function will return -EBUSY and
+ * the register will not be written to.
+ *
+ * If the register does not have any space to write into, then -EAGAIN will
+ * be returned.
+ *
+ * @param dev_num The logical device number of the device to use.
+ * @param reg_id The ID of the register to write to.
+ * @param value The value to write to the register.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_register_write( unsigned dev_num,
+                       unsigned reg_id,
+                       u32 value );
+
+/*!
+ * Read from a general purpose register (GPR) in a picoArray. It is possible
+ * that the reg_id may be a valid register but is being used exclusively for a
+ * transport. If this is the case then this function will return -EBUSY and
+ * the register will not be read from.
+ *
+ * If the register does not have any data available to read, then -EAGAIN will
+ * be returned.
+ *
+ * @param dev_num The logical device number of the device to use.
+ * @param reg_id The ID of the register to write to.
+ * @param[out] value A pointer to the address where the register value should
+ * be stored.
+ * @return Returns zero on success, negative on failure.
+ */
+int
+picoif_register_read( unsigned dev_num,
+                      unsigned reg_id,
+                      u32 *value );
+
+/*!
+ * Perform a picoArray load by multiple loads to the configuration bus write
+ * port.
+ *
+ * @param dev_num The logical device number to write to.
+ * @param buf Pointer to an array of u32s to write.
+ * @return Returns the number of 32-bit words written on success, negative on
+ * failure.
+ */
+int
+picoif_pa_load( unsigned dev_num,
+                u32 *buf,
+                struct scatterlist *sgl );
+
+/*!
+ * Get the number of devices in the system.
+ *
+ * @return Returns the number of devices in the system.
+ */
+unsigned
+picoif_num_devices( void );
+
+/*!
+ * Reset all of the devices in the system.
+ *
+ * @return Returns zero on success, non-zero on failure.
+ */
+int
+picoif_reset( void );
+
+/*!
+ * Start all devices running.
+ *
+ * @return returns zero on success, non-zero on failure.
+ */
+int
+picoif_start_all( void );
+
+/*!
+ * Stop all devices running.
+ *
+ * @return returns zero on success, non-zero on failure.
+ */
+int
+picoif_stop_all( void );
+
+/*! @} */
+
+/*!
+ * Generic read method for transport instances in kernelspace. This is used
+ * to read from a transport instance when the transport type is unknown and
+ * the transport specific read function is simply a wrapper around this.
+ *
+ * @param ctx The context to read from.
+ * @param buf The buffer to store the data read into.
+ * @param len The maximum number of bytes to read.
+ * @return Returns the number of bytes read on success, negative on failure.
+ */
+ssize_t
+picoif_transport_generic_read( struct picoif_context *ctx,
+                               u8 *buf,
+                               size_t len );
+
+/*!
+ * Generic write method for transport instances in kernelspace. This is used
+ * to write to a transport instance when the transport type is unknown and
+ * the transport specific write function is simply a wrapper around this.
+ *
+ * @param ctx The context to write to.
+ * @param buf The buffer of data to write.
+ * @param len The maximum number of bytes to write.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+ssize_t
+picoif_transport_generic_write( struct picoif_context *ctx,
+                                const u8 *buf,
+                                size_t len );
+
+/*!
+ * Generic scatterlist write method for transport instances in kernelspace.
+ * This is used to write to a transport instance when the transport type is
+ * unknown and the transport specific write function is simply a wrapper
+ * around this.
+ *
+ * @param ctx The context to write to.
+ * @param sgl The data to write.
+ * @param n_ents The number of entries in the scatterlist.
+ * @param cookie The cookie to pass to the callback.
+ * @return Returns the number of bytes written on success, negative on
+ * failure.
+ */
+ssize_t
+picoif_transport_generic_writesg( struct picoif_context *ctx,
+                                  struct scatterlist *sgl,
+                                  unsigned n_ents,
+				  void *cookie );
+
+/*!
+ * Generic close method for a transport instance in kernelspace. This is used
+ * to close a transport instance when the transport type is unknown and the
+ * transport specific close function is simply a wrapper around this.
+ *
+ * @param ctx The transport instance to close.
+ */
+void
+picoif_transport_generic_close( struct picoif_context *ctx );
+
+/*! @} */
+
+#endif /* !__PICOIF_PICOIF_H__ */
diff --git a/include/linux/picochip/picoif_ioctl.h b/include/linux/picochip/picoif_ioctl.h
new file mode 100644
index 0000000..dadf6ef
--- /dev/null
+++ b/include/linux/picochip/picoif_ioctl.h
@@ -0,0 +1,200 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file picoif_ioctl.h
+ * \brief Definition of picoIf ioctl types and associated data.
+ *
+ * This file defines the ioctl() calls used for picoIf configuration and any
+ * associated shared structures that are used to pass data from userspace into
+ * kernelspace.
+ */
+
+#ifndef __PICOIF_PICOIF_IOCTL_H__
+#define __PICOIF_PICOIF_IOCTL_H__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <asm/ioctl.h>
+#else /* __KERNEL__ */
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+#define __user
+#endif /* __KERNEL__ */
+
+/*!
+ * \brief Structure to pass config read/write requests between userspace and
+ * the kernel.
+ */
+struct picoif_cfg_req
+{
+    __u16           dev;        /*!< Logical picoArray device number to use. */
+    __u16           caeid;      /*!< CAEID to address. */
+    __u16           ae_addr;    /*!< The address inside the AE. */
+    __u16 __user    *buf;       /*!< The buffer to read/write from/to. */
+    unsigned        count;      /*!< The number of 16 bit words to read/write. */
+};
+
+/*!
+ * \brief Structure to pass a request for a new transport instance from
+ * userspace to the kernel.
+ */
+struct picoif_new_trans_req
+{
+    const char      description[ 32 ];  /*!< Description of the transport
+                                         *   type. */
+    void __user     *params;            /*!< Extra parameters for the
+                                         *   transport. */
+};
+
+/*!
+ * \brief Structure to pass register read/write requests between userspace and
+ * the kernel.
+ */
+struct picoif_reg_req
+{
+    __u16           dev;        /*!< Logical picoArray device number to use. */
+    __u16           reg_id;     /*!< The register to read/write. */
+    __u32           value;      /*!< The value of the register. */
+};
+
+/*!
+ * \brief Structure to pass multiple config write requests between
+ * userspace and the kernel.
+ */
+struct picoif_multi_reg_req
+{
+    __u16           dev;        /*!< Logical picoArray device number to use. */
+    __u32 __user    *buf;       /*!< The buffer to write to. */
+    __u32           count;      /*!< The number of 32 bit words to write. */
+};
+
+/*! The magic number for picoIf ioctl() messages. */
+#define PICOIF_IOC_MAGIC       'p'
+
+/* Lint errors 835, 506, 845, 944, 944, and 831 are supressed in these
+ * definitions as the warnings are generated by the magic ioctl code and can't
+ * be fixed here. */
+
+/*! Config read request. */
+#define PICOIF_IOC_CFG_READ    /*lint -e(835, 506, 845, 941, 944, 831)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 0, \
+                                      struct picoif_cfg_req )
+
+/*! Config write request. */
+#define PICOIF_IOC_CFG_WRITE   /*lint -e(835, 506, 845, 944, 831 )*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 1, \
+                                      struct picoif_cfg_req )
+
+/*! Multi Config write request. */
+#define PICOIF_IOC_MULTI_CFG_WRITE   /*lint -e(835, 506, 845, 831, 944)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 2, \
+                                      struct picoif_multi_reg_req )
+
+/*! Register read request. */
+#define PICOIF_IOC_REG_READ    /*lint -e(835, 506, 845, 944, 831)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 3, \
+                                      struct picoif_reg_req )
+
+/*! Register write request. */
+#define PICOIF_IOC_REG_WRITE   /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 4, \
+                                      struct picoif_reg_req )
+
+/*! Request to reset all picoArrays. */
+#define PICOIF_IOC_RESET       /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IO( PICOIF_IOC_MAGIC, 5 )
+
+/*! Request to get the number of picoArrays in the system */
+#define PICOIF_IOC_NUMDEV      /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IOR( PICOIF_IOC_MAGIC, 6, unsigned )
+
+/*! Convert a file descriptor into a transport instance. */
+#define PICOIF_IOC_NEW_TRANS   /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IOWR( PICOIF_IOC_MAGIC, 7, \
+                                      struct picoif_new_trans_req )
+
+/*! Request to start all picoArrays. */
+#define PICOIF_IOC_STARTALL    /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IO( PICOIF_IOC_MAGIC, 8 )
+
+/*! Request to stop all picoArrays. */
+#define PICOIF_IOC_STOPALL    /*lint -e(835, 506, 845, 944, 831, 941)*/ \
+                               _IO( PICOIF_IOC_MAGIC, 9 )
+
+/*! The number of picoIf ioctl()s. */
+#define PICOIF_IOC_NUM         ( 10 )
+
+/*!
+ * \brief Structure to pass parameters for a new GPR interrupt transport
+ * instance.
+ */
+struct picoif_gpr_int_params
+{
+    unsigned        dev_num;        /*!< The logical device number to use. */
+    int             irq_num;        /*!< The GPR IRQ number to use. */
+};
+
+/*!
+ * \brief Structure to pass parameters for a new DMA DL/UL transport
+ * instance.
+ */
+struct picoif_dma_params
+{
+    unsigned        dev_num;        /*!< The logical device number to use. */
+    int             channel;        /*!< The DMA channel to use. */
+    size_t          buf_size;       /*!< The buffer size to use. */
+};
+
+/*!
+ * \brief Structure to pass parameters for a new HwIF UL transport
+ * instance.
+ */
+struct picoif_hwif_params
+{
+    unsigned        dev_num;        /*!< The picoArray to use. */
+    int             int_clear_gpr;  /*!< The interrupt clear GPR to use. */
+    unsigned        int_num;        /*!< Interrupt number to use. */
+    int             channel;        /*!< The DMA channel to use. */
+    size_t          buf_size;       /*!< The buffer size to use. */
+    int             status_gpr;     /*!< The Status GPR */
+    int             count_gpr;      /*!< The count GPR */
+};
+
+/*!
+ * \brief Structure to pass parameters for a new HwIF 2 UL transport
+ * instance.
+ */
+struct picoif_hwif2_params
+{
+    unsigned        dev_num;        /*!< Device number to use. */
+    unsigned        int_num;        /*!< Interrupt number to use. */
+    int             channel;        /*!< The DMA channel to use. */
+    size_t          buf_size;       /*!< The buffer size to use. */
+    int             its_gpr;        /*!< The ITS GPR */
+    int             itm_gpr;        /*!< The ITM GPR */
+};
+
+struct picoif_directdma_params
+{
+    unsigned        dev_num;        /*!< The logical device number to use. */
+    int             channel;        /*!< The DMA channel to use. */
+    /*! The callback for completed transfers. */
+    void	    ( *callback )( size_t nbytes,
+				   void *cookie );
+    void	    *cookie;
+};
+
+#endif /* !__PICOIF_PICOIF_IOCTL_H__ */
diff --git a/include/linux/picochip/transports/directdma.h b/include/linux/picochip/transports/directdma.h
new file mode 100644
index 0000000..996021b
--- /dev/null
+++ b/include/linux/picochip/transports/directdma.h
@@ -0,0 +1,82 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file directdma.h
+ *
+ * \brief Public picoIf Direct DMA transport method kernel API.
+ *  \addtogroup kernelAPI
+ *  @{
+ *   \addtogroup DMA
+ *    @{
+ */
+
+#ifndef __PICOIF_PUBLIC_DIRECTDMA_H__
+#define __PICOIF_PUBLIC_DIRECTDMA_H__
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+
+struct picoif_context;
+
+/*!
+ * Open a new instance of the direct DMA transport.
+ *
+ * @param dev_num The logical device number of the picoArray to use.
+ * @param dma_chan The identifier of the DMA channel to use. This should be
+ * taken from the picoifDMAId_t enumeration for the appropriate device type.
+ * @param buf_size The size of buffer in bytes to allocate for this channel
+ * @param callback The callback to call at transfer completion.
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_directdma_open( unsigned dev_num,
+                       int dma_chan,
+                       void ( *callback )( size_t nbytes,
+                                           void *cookie ) );
+
+/*!
+ * Write to the data supplied in a kernel mapped buffer into a DMA transport.
+ *
+ * @param ctx The open context of the transport.
+ * @param sgl The data to write.
+ * @param n_ents The number of entries in the scatterlist.
+ * @return Returns the number of bytes written to the transport on success,
+ * negative on failure. If there is no space in the transport to buffer the
+ * data the -EAGAIN is returned.
+ */
+static inline ssize_t
+picoif_directdma_writesg( struct picoif_context *ctx,
+                          struct scatterlist *sgl,
+                          unsigned n_ents,
+			  void *cookie )
+{
+    return picoif_transport_generic_writesg( ctx, sgl, n_ents, cookie );
+}
+
+/*!
+ * Close an open instance of a direct DMA transport.
+ *
+ * @param ctx The context to close.
+ */
+static inline void
+picoif_directdma_close( struct picoif_context *ctx )
+{
+    picoif_transport_generic_close( ctx );
+}
+
+/*! @} */
+/*! @} */
+
+#endif /* !__PICOIF_PUBLIC_DIRECTDMA_H__ */
diff --git a/include/linux/picochip/transports/dma.h b/include/linux/picochip/transports/dma.h
new file mode 100644
index 0000000..e29062e
--- /dev/null
+++ b/include/linux/picochip/transports/dma.h
@@ -0,0 +1,116 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file dma.h
+ *
+ * \brief Public picoIf DMA transport method kernel API.
+ *  \addtogroup kernelAPI
+ *  @{
+ *   \addtogroup DMA
+ *    @{
+ */
+
+#ifndef __PICOIF_PUBLIC_DMA_H__
+#define __PICOIF_PUBLIC_DMA_H__
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+
+struct picoif_context;
+
+/*!
+ * Open a new instance of the DMA DL transport.
+ *
+ * @param dev_num The logical device number of the picoArray to use.
+ * @param dma_chan The identifier of the DMA channel to use. This should be
+ * taken from the picoifDMAId_t enumeration for the appropriate device type.
+ * @param buf_size The size of buffer in bytes to allocate for this channel
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_dma_open_dl( unsigned dev_num,
+                    int dma_chan,
+                    size_t buf_size );
+
+/*!
+ * Open a new instance of the DMA UL transport.
+ *
+ * @param dev_num The logical device number of the picoArray to use.
+ * @param dma_chan The identifier of the DMA channel to use. This should be
+ * taken from the picoifDMAId_t enumeration for the appropriate device type.
+ * @param buf_size The size of buffer in bytes to allocate for this channel
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_dma_open_ul( unsigned dev_num,
+                    int dma_chan,
+                    size_t buf_size );
+
+/*!
+ * Read from the DMA channel up to the size of data specified
+ *
+ * @param ctx The open context of the transport.
+ * @param buf The buffer to write the DMA'd data into.
+ * @param len The length of the buffer in bytes. Non multiples of 4 bytes
+ * are accepted but DMA transfers must be multiples of 4 bytes. This means
+ * that bytes may be left over and held until the next DMA transfer.
+ * @return Returns the number of bytes read into the buffer on success,
+ * negative on failure. If no data is available to read, the -EAGAIN will be
+ * returned.
+ */
+static inline ssize_t
+picoif_dma_read( struct picoif_context *ctx,
+                 u8 *buf,
+                 size_t len )
+{
+    return picoif_transport_generic_read( ctx, buf, len );
+}
+
+/*!
+ * Write to the data supplied in a kernel mapped buffer into a DMA transport.
+ *
+ * @param ctx The open context of the transport.
+ * @param buf The buffer containing the data to transfer by DMA.
+ * @param len The length of the buffer in bytes. Non multiples of 4 bytes
+ * are accepted but DMA transfers must be multiples of 4 bytes. This means
+ * that bytes may be left over and held until the next DMA transfer.
+ * @return Returns the number of bytes written to the transport on success,
+ * negative on failure. If there is no space in the transport to buffer the
+ * data the -EAGAIN is returned.
+ */
+static inline ssize_t
+picoif_dma_write( struct picoif_context *ctx,
+                  u8 *buf,
+                  size_t len )
+{
+    return picoif_transport_generic_write( ctx, buf, len );
+}
+
+/*!
+ * Close an open instance of a DMA transport.
+ *
+ * @param ctx The context to close.
+ */
+static inline void
+picoif_dma_close( struct picoif_context *ctx )
+{
+    picoif_transport_generic_close( ctx );
+}
+
+/*! @} */
+/*! @} */
+
+#endif /* !__PICOIF_PUBLIC_DMA_H__ */
diff --git a/include/linux/picochip/transports/gpr_interrupt.h b/include/linux/picochip/transports/gpr_interrupt.h
new file mode 100644
index 0000000..5a37f2d
--- /dev/null
+++ b/include/linux/picochip/transports/gpr_interrupt.h
@@ -0,0 +1,99 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file gpr_interrupt.h
+ *
+ * \brief Public picoIf GPR interrupt transport method kernel API.
+ *  \addtogroup kernelAPI
+ *  @{
+ *   \addtogroup GPRIrq
+ *    @{
+ */
+
+#ifndef __PICOIF_PUBLIC_GPR_INTERRUPT_H__
+#define __PICOIF_PUBLIC_GPR_INTERRUPT_H__
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+
+struct picoif_context;
+
+/*!
+ * Open a new instance of the GPR interrupt transport.
+ *
+ * @param dev_num The logical device number of the picoArray to use.
+ * @param irq_num The identifier of the GPR number to use. This should be
+ * taken from the picoifGPRId_t enumeration.
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_gpr_irq_ul( unsigned dev_num,
+                   int irq_num );
+
+/*!
+ * Open a new instance of the GPR interrupt transport. This is like
+ * picoif_gpr_irq_ul() but rather than the read method returning the number of
+ * interrupts raised, the buffer will contain the values of the GPR at the
+ * time the interrupt was raised.
+ *
+ * @param dev_num The logical device number of the picoArray to use.
+ * @param irq_num The identifier of the IRQ source to use. This should be
+ * taken from the picoifIRQId_t enumeration.
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_gpr_irq_ul_with_values( unsigned dev_num,
+                               int irq_num );
+
+/*!
+ * Read from the GPR interrupt transport. If the values are not being
+ * recorded, the number of interrupts raised since the transport has last read
+ * will be encoded in host byte order in the first 4 bytes of the buffer so
+ * buf must be at least 4 bytes long. Alternatively, if the values are being
+ * recorded, then buf will contain the values of the GPR at interrupt time
+ * encoded in host byte order and the number of interrupts raised will be the
+ * return value divided by sizeof( u32 ).
+ *
+ * @param ctx The open context of the transport.
+ * @param buf The buffer to write the transport data into.
+ * @param len The length of the buffer in bytes.
+ * @return Returns the number of bytes read into the buffer on success,
+ * negative on failure. If no interrupts have been raised, then -EAGAIN will
+ * be returned.
+ */
+static inline ssize_t
+picoif_gpr_irq_ul_read( struct picoif_context *ctx,
+                        u8 *buf,
+                        size_t len )
+{
+    return picoif_transport_generic_read( ctx, buf, len );
+}
+
+/*!
+ * Close an open instance of a GPR interrupt transport.
+ *
+ * @param ctx The context to close.
+ */
+static inline void
+picoif_gpr_irq_ul_close( struct picoif_context *ctx )
+{
+    picoif_transport_generic_close( ctx );
+}
+
+/*! @} */
+/*! @} */
+
+#endif /* !__PICOIF_PUBLIC_GPR_INTERRUPT_H__ */
diff --git a/include/linux/picochip/transports/hwif2.h b/include/linux/picochip/transports/hwif2.h
new file mode 100644
index 0000000..5d3c3f5
--- /dev/null
+++ b/include/linux/picochip/transports/hwif2.h
@@ -0,0 +1,131 @@
+/*****************************************************************************
+ * $picoChipHeaderSubst$
+ *****************************************************************************/
+
+/*
+ * Copyright (c) 2009 picoChip Designs Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * All enquiries to support@picochip.com
+ */
+
+/*!
+ * \file hwif2.h
+ *
+ * \brief Public picoIf HwIf2 transport method kernel API.
+ *  \addtogroup kernelAPI
+ *  @{
+ *   \addtogroup HwIf2
+ *    @{
+ */
+
+#ifndef __PICOIF_PUBLIC_HWIF2_H__
+#define __PICOIF_PUBLIC_HWIF2_H__
+#include <linux/types.h>
+#include <linux/picochip/picoif.h>
+
+struct picoif_context;
+
+/*!
+ * \brief Structure for the storage of the context in the HwIF2 transport
+ */
+struct picoif_hwif2
+{
+    unsigned  dev_num;       /*!< The device number to use in the transport. */
+    int its_gpr;             /*!< The uplink handshaking GPR. */
+    int itm_gpr;             /*!< The downlink handshaking GPR */
+};
+
+/*! Opaque pointer for the picoIf HwIf context. */
+typedef struct picoif_hwif2 * picoif_hwif2_t;
+
+/*!
+ * Initialise a context (one per device) to support all HwIF2 UL transports.
+ * Once finished with, the context should be destroyed with
+ * picoifHwIF2_DestroyContext().
+ *
+ * \param dev_num The logical device number to use for the transport.
+ * \param its_gpr The GPR for handshaking in the picoArray to host direction.
+ *      This value should be taken from the picoIfGPRId_t enumeration.
+ * \param itm_gpr The GPR for handshaking in the host to picoArray direction.
+ *      This value should be taken from the picoIfGPRId_t enumeration.
+ * \return Returns a HwIF2 context.
+ */
+picoif_hwif2_t
+picoif_hwif2_init( unsigned dev_num,
+                   int its_gpr,
+                   int itm_gpr );
+
+/*!
+ * Destroy a HwIf2 context used for creating transports. This may be safely
+ * destroyed once all transports using the context have been opened.
+ *
+ * \param context The context to destroy.
+ */
+void
+picoif_hwif2_destroy_context( picoif_hwif2_t context );
+
+/*!
+ * Create a new instance of a HwIF2 uplink DMA transport. This transport
+ * will allow DMA transfers from a picoArray DMA channel into a user buffer
+ * using the HwIF2 mechanism. On success, a file descriptor is returned which
+ * may be read to transfer the data. When read(2) is called on the file
+ * descriptor, a transfer of all available bytes up to the specified number is
+ * made. By default this transport is configured in blocking mode but can be
+ * converted to non-blocking using the fcntl(2) command.
+ *
+ * \param[in] hwif2_context The HwIF2 context created by picoifHwIF2_Init()
+ * \param interrupt_number The interrupt number to initiate a new transfer.
+ * \param dma_channel The DMA channel in the picoArray to use for the
+ *      transport. This value should be taken from the picoIfDMAId_t
+ *      enumeration.
+ * \param buffer_size The internal buffer size used for DMA transfers in bytes.
+ *      This should be large enough such that it does not often fill up and
+ *      reduce throughput.
+ * @return Returns a context on success, or an ERR_PTR encoded error on
+ * failure.
+ */
+struct picoif_context *
+picoif_hwif2_dmaul_open( const picoif_hwif2_t hwif2_context,
+                         unsigned interrupt_number,
+                         int dma_channel,
+                         size_t buffer_size );
+
+/*!
+ * Read from the HwIf2 DMA channel up to the size of data specified
+ *
+ * @param ctx The open context of the transport.
+ * @param buf The buffer to write the DMA'd data into.
+ * @param len The length of the buffer in bytes. Non multiples of 4 bytes
+ * are accepted but DMA transfers must be multiples of 4 bytes. This means
+ * that bytes may be left over and held until the next DMA transfer.
+ * @return Returns the number of bytes read into the buffer on success,
+ * negative on failure. If no data is available to read, the -EAGAIN will be
+ * returned.
+ */
+static inline ssize_t
+picoif_hwif2_dmaul_read( struct picoif_context *ctx,
+                         u8 *buf,
+                         size_t len )
+{
+    return picoif_transport_generic_read( ctx, buf, len );
+}
+
+/*!
+ * Close an open instance of a HwIf2 DMA transport.
+ *
+ * @param ctx The context to close.
+ */
+static inline void
+picoif_hwif2_dmaul_close( struct picoif_context *ctx )
+{
+    picoif_transport_generic_close( ctx );
+}
+
+/*! @} */
+/*! @} */
+
+#endif /* !__PICOIF_PUBLIC_HWIF2_H__ */
-- 
1.7.0.4

